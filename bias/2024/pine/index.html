<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> PINE: Position-INvariant inferencE | Shirin Tahmasebi </title> <meta name="author" content="Shirin Tahmasebi"> <meta name="description" content="Position Bias in LLMs "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?ce48ee9bc248ee6b18f3aeefc03ed2f9"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://shirintahmasebi.github.io/bias/2024/pine/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Shirin Tahmasebi </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">CV </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">Publications</a> <a class="dropdown-item " href="/background/">Background</a> </div> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Notes </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/bias/">Bias</a> <a class="dropdown-item " href="/tokenization/">Tokenization</a> <a class="dropdown-item " href="/llm_judge/">LLM as Evaluator</a> <a class="dropdown-item " href="/prompt/">Prompt Engineering</a> <a class="dropdown-item " href="/compression/">LLM Compression</a> <a class="dropdown-item " href="/agents/">LLM Agents</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/recsys/">Recommendation Systems</a> <a class="dropdown-item " href="/other/">Others</a> </div> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">PINE: Position-INvariant inferencE</h1> <p class="post-meta"> October 06, 2024 </p> <p class="post-tags"> <i class="fa-solid fa-calendar fa-sm"></i> 2024   ·   <i class="fa-solid fa-hashtag fa-sm"></i> bias   <i class="fa-solid fa-hashtag fa-sm"></i> position-bias   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"> <a href="#eliminating-position-bias-of-language-models-a-mechanistic-approach">Eliminating Position Bias of Language Models: A Mechanistic Approach</a> <ul> <li class="toc-entry toc-h3"><a href="#introduction">Introduction</a></li> <li class="toc-entry toc-h3"><a href="#research-gap">Research Gap</a></li> <li class="toc-entry toc-h3"> <a href="#background">Background</a> <ul> <li class="toc-entry toc-h4"> <a href="#causal-attention">Causal Attention</a> <ul> <li class="toc-entry toc-h5"><a href="#limitations-of-causal-attention">Limitations of Causal Attention</a></li> </ul> </li> <li class="toc-entry toc-h4"> <a href="#bidirectional-attention">Bidirectional Attention</a> <ul> <li class="toc-entry toc-h5"><a href="#advantages-of-bidirectional-attention">Advantages of Bidirectional Attention</a></li> </ul> </li> <li class="toc-entry toc-h4"><a href="#why-pine-uses-bidirectional-attention">Why PINE Uses Bidirectional Attention</a></li> </ul> </li> <li class="toc-entry toc-h3"> <a href="#solution-pine">Solution: PINE</a> <ul> <li class="toc-entry toc-h4"><a href="#key-components-of-pine">Key Components of PINE</a></li> <li class="toc-entry toc-h4"><a href="#practical-implementation">Practical Implementation</a></li> <li class="toc-entry toc-h4"><a href="#benefits-of-pine">Benefits of PINE</a></li> <li class="toc-entry toc-h4"><a href="#limitations-of-pine">Limitations of PINE</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#experiments">Experiments</a></li> <li class="toc-entry toc-h3"><a href="#conclusion">Conclusion</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <h2 id="eliminating-position-bias-of-language-models-a-mechanistic-approach"><a href="https://openreview.net/pdf?id=fvkElsJOsN" rel="external nofollow noopener" target="_blank">Eliminating Position Bias of Language Models: A Mechanistic Approach</a></h2> <h3 id="introduction">Introduction</h3> <p>Position bias is an important issue in modern LLMs, where the relative position of input elements significantly impacts the model’s outputs. This bias poses challenges in tasks that require fair or consistent decision-making, such as ranking, question answering, and reasoning. For instance, LMs often favor the first option in ranking tasks or prioritize content appearing earlier in retrieval-based contexts, undermining their reliability. Despite various attempts to mitigate position bias through training or heuristic methods, a comprehensive, architecture-independent solution remains elusive. To address this, the paper introduces <strong>PINE (Position-INvariant inferencE)</strong>, a novel <strong>training-free</strong> approach that eliminates position bias by leveraging bidirectional attention and dynamic position reassignment during inference.</p> <h3 id="research-gap">Research Gap</h3> <p>While existing works on position bias mitigation have made progress, they primarily focus on ad-hoc solutions such as training data augmentation, heuristic content reordering, or model calibration. These approaches often rely on task-specific assumptions, leading to limited generalizability and increased computational overhead during training or fine-tuning. Furthermore, prior methods either fail to completely eliminate position bias or introduce unacceptable performance trade-offs in tasks requiring precise language generation. There is a clear need for a robust, task-agnostic approach that operates without retraining or fine-tuning and achieves position invariance across a wide range of applications. The PINE framework bridges this gap by proposing a mechanistic solution that ensures position-independent outputs while maintaining the efficiency and integrity of pre-trained language models.</p> <h3 id="background">Background</h3> <p>Understanding <strong>causal attention</strong> and <strong>bidirectional attention</strong> is key to grasping how PINE mitigates position bias in language models. These attention mechanisms play a central role in how transformers process and prioritize input sequences.</p> <h4 id="causal-attention">Causal Attention</h4> <p>Causal attention is a mechanism used in transformer-based models, particularly in autoregressive language models like GPT. It ensures that the model generates text sequentially by attending only to earlier tokens in the input. Here’s how it works:</p> <ul> <li> <strong>Mechanism</strong>: In causal attention, a <strong>mask</strong> is applied to the attention computation. This mask blocks any token from “looking ahead” to future tokens during processing. For example, when predicting the third word in a sequence, the model can only consider the first two words.</li> <li> <strong>Mathematical Representation</strong>: \(\text{Attention}(Q, K, V) = \text{Softmax}\left(\frac{QK^T}{\sqrt{d}} + \text{Mask}\right)V\) <ul> <li>\(Q\): Query vectors.</li> <li>\(K\): Key vectors.</li> <li>\(V\): Value vectors.</li> <li>The <strong>Mask</strong> ensures that for any token \(t\), only tokens \(\leq t\) are considered.</li> </ul> </li> <li> <strong>Use Case</strong>: This mechanism is crucial for generating coherent and grammatically correct sequences in tasks like text completion, where each token depends only on previous context.</li> </ul> <h5 id="limitations-of-causal-attention">Limitations of Causal Attention</h5> <ul> <li> <strong>Directional Bias</strong>: By design, causal attention inherently favors earlier tokens in the sequence. This bias can be problematic for tasks requiring an understanding of all tokens equally, such as ranking tasks or retrieval-based question answering.</li> <li> <strong>Position Dependence</strong>: Since causal attention assumes an ordered sequence, the position of input elements significantly influences the model’s output.</li> </ul> <h4 id="bidirectional-attention">Bidirectional Attention</h4> <p>Bidirectional attention, in contrast, allows tokens to attend to every other token in the sequence, regardless of their position. It is typically used in models designed for non-sequential tasks, such as BERT, where understanding the entire context simultaneously is essential.</p> <ul> <li> <strong>Mechanism</strong>: No masking is applied in bidirectional attention, enabling all tokens to interact with each other freely. Each token can “look” both forward and backward within the sequence.</li> <li> <strong>Mathematical Representation</strong>: \(\text{Attention}(Q, K, V) = \text{Softmax}\left(\frac{QK^T}{\sqrt{d}}\right)V\) <ul> <li>Unlike causal attention, no restrictions are imposed on the positions of tokens during the attention computation.</li> </ul> </li> <li> <strong>Use Case</strong>: Bidirectional attention is well-suited for tasks requiring a global understanding of the input, such as classification, reasoning, or comparing input elements (e.g., ranking responses).</li> </ul> <h5 id="advantages-of-bidirectional-attention">Advantages of Bidirectional Attention</h5> <ul> <li> <strong>Position-Invariance</strong>: All tokens are treated equally, reducing position dependence and bias.</li> <li> <strong>Contextual Understanding</strong>: By considering the entire input, bidirectional attention captures richer relationships between tokens.</li> </ul> <h4 id="why-pine-uses-bidirectional-attention">Why PINE Uses Bidirectional Attention</h4> <p>The PINE framework adopts <strong>bidirectional attention</strong> between input segments to eliminate <strong>inter-segment position bias</strong>. For example, in a retrieval-based QA task, documents retrieved as input should not influence the output based on their order. By using bidirectional attention, PINE ensures all segments are equally considered, regardless of their position in the input sequence.</p> <p>At the same time, <strong>causal attention</strong> is retained within individual segments to preserve local sequential dependencies. This hybrid approach balances the benefits of both mechanisms, enabling position-invariant processing without losing the ability to handle sequence-level structures.</p> <h3 id="solution-pine">Solution: PINE</h3> <p>The paper proposes <strong>PINE (Position-INvariant inferencE)</strong> as a training-free and generalizable solution to eliminate position bias in language models. Instead of requiring model retraining or fine-tuning, PINE introduces runtime modifications during inference that ensure the model processes all input content fairly, regardless of its position. Here’s how the approach works in detail:</p> <h4 id="key-components-of-pine">Key Components of PINE</h4> <ol> <li>Bidirectional Attention: <ul> <li>Standard language models often use <strong>causal attention</strong>, which prioritizes sequential inputs (e.g., earlier tokens or documents). This can cause position bias, as the model disproportionately favors certain parts of the input.</li> <li>PINE replaces causal attention with <strong>bidirectional attention</strong> between input segments (e.g., retrieved documents in QA tasks). This ensures all segments can influence each other equally, eliminating inter-segment bias.</li> <li>Within each segment (e.g., words within a document), <strong>causal attention</strong> is retained to preserve local sequential dependencies.</li> </ul> </li> <li>Dynamic Position Reassignment Using Importance Scores: <ul> <li>PINE calculates an <strong>importance score</strong> for each input segment during inference. This score quantifies the relevance of each segment to the task and is based on the model’s internal attention values.</li> <li>Here’s how the importance score is calculated: <ol> <li> <strong>Pairwise Importance Score Calculation</strong>: <ul> <li>For each pair of input segments (e.g., documents), PINE computes a <strong>pairwise importance score</strong>. This score represents how much one document influences or is relevant to another.</li> <li>The pairwise importance score between document \(D_1\) and \(D_2\) is calculated as the average attention weights between the tokens of \(D_1\) and \(D_2\):</li> </ul> \[\text{Importance}(D_1, D_2) = \frac{1}{|D_2|} \sum_{i \in D_1} \sum_{j \in D_2} \text{Softmax} \left( \frac{Q_i \cdot K_j^T}{\sqrt{d}} \right)\] <ul> <li>Here: <ul> <li>\(Q_i\) and \(K_j\) are the query and key vectors of tokens \(i\) and \(j\), respectively.</li> <li>\(d\) is the hidden dimension size.</li> <li>\(\vert D_2 \vert\) normalizes the score to prevent longer documents from being unfairly prioritized.</li> </ul> </li> </ul> </li> <li> <strong>Aggregate Scores for Each Document</strong>: <ul> <li>After computing the pairwise importance scores for all document pairs, the scores are aggregated for each document. This gives an overall <strong>importance score</strong> for each document:</li> </ul> \[\text{Total Importance}(D_i) = \sum_{j \neq i} \text{Importance}(D_i, D_j)\] <ul> <li>This step ensures that each document’s relevance is considered in the context of all other documents.</li> </ul> </li> <li> <strong>Sorting Documents by Importance</strong>: <ul> <li>Based on the aggregated scores, the documents are sorted in descending order of their total importance scores.</li> <li>The most relevant documents (i.e., those with the highest scores) are placed closer to the query or processing focus, while less relevant documents are placed further away.</li> </ul> </li> <li> <strong>Reassignment of Positions</strong>: <ul> <li>After sorting, PINE reassigns the positions of documents in the input sequence according to their importance ranking. This step ensures that the document order in the input no longer impacts the model’s output, as the order is determined by content relevance rather than arbitrary position.</li> </ul> </li> </ol> </li> </ul> </li> <li> <strong>Position-Invariant Outputs</strong>: <ul> <li>By combining <strong>bidirectional attention</strong> and <strong>dynamic position reassignment</strong>, PINE ensures that the model’s outputs remain consistent regardless of the input order. This eliminates the systematic biases caused by positional encodings or causal attention.</li> </ul> </li> </ol> <h4 id="practical-implementation">Practical Implementation</h4> <p>PINE operates entirely during <strong>inference</strong>:</p> <ul> <li>It modifies the <strong>attention masks</strong> to enable bidirectional attention between segments.</li> <li>It dynamically recalculates positional encodings based on the computed importance scores and reassigns positions accordingly.</li> <li>The model’s pre-trained weights and architecture are left untouched, making PINE a plug-and-play solution for open-source models.</li> </ul> <h4 id="benefits-of-pine">Benefits of PINE</h4> <ul> <li> <strong>Training-Free</strong>: PINE avoids retraining or fine-tuning, significantly reducing computational costs.</li> <li> <strong>Task-General</strong>: It demonstrates effectiveness across diverse applications, including ranking, QA, reasoning, and molecule generation.</li> <li> <strong>Robustness</strong>: By ensuring position-invariance, PINE enhances fairness and reliability in decision-making tasks.</li> </ul> <h4 id="limitations-of-pine">Limitations of PINE</h4> <p>While PINE offers a compelling solution to position bias, it has the following limitations:</p> <ol> <li> <strong>Open-Source Model Requirement</strong>: <ul> <li>PINE requires access to the model’s internal mechanisms, such as attention weights and positional encodings. This makes it incompatible with black-box models like GPT (accessible via APIs), where such modifications are not possible.</li> </ul> </li> <li> <strong>Inference Overhead</strong>: <ul> <li>The computation of importance scores and position reassignment adds computational cost during inference. For instance, sorting operations introduce a complexity of \(O(nk \log k)\), where \(n\) is the token count and \(k\) is the number of input segments.</li> </ul> </li> <li> <strong>Limited Scope</strong>: <ul> <li>PINE is designed to address <strong>position bias</strong> specifically. It does not tackle other biases inherent in language models, such as biases in training data or representation.</li> </ul> </li> </ol> <p>Despite these limitations, PINE represents a significant step forward in addressing position bias and provides a powerful, adaptable solution for open-source transformer models.</p> <h3 id="experiments">Experiments</h3> <p>The authors evaluate PINE across four diverse tasks to demonstrate its effectiveness in eliminating position bias:</p> <ol> <li> <p><strong>LM-as-a-Judge</strong>:<br> Models compare two responses to a question, where position bias often leads to favoring the first response. PINE improves accuracy by 8-10 percentage points, particularly excelling in reasoning tasks.</p> </li> <li> <p><strong>Retrieval-Augmented QA</strong>:<br> Models answer questions based on a set of retrieved documents. Without PINE, performance depends on whether the relevant document appears early or late. PINE ensures position-invariant results while maintaining high accuracy.</p> </li> <li> <p><strong>Molecule Generation</strong>:<br> LMs generate molecules based on several input properties. PINE improves generation accuracy across five out of six evaluated criteria by treating property order as position-invariant.</p> </li> <li> <p><strong>Math Reasoning</strong>:<br> Tested on a dataset with interchangeable premise orders, PINE boosts reasoning accuracy by 5-12 percentage points, proving its utility in logic-based tasks.</p> </li> </ol> <p>Across tasks, PINE consistently reduces position bias and enhances model performance while maintaining efficiency.</p> <h3 id="conclusion">Conclusion</h3> <p>The PINE framework represents a significant step forward in addressing position bias in language models. By leveraging bidirectional attention and dynamically reassigning input positions based on relevance, PINE eliminates reliance on arbitrary input order, enabling position-invariant inference without requiring retraining or fine-tuning. Its effectiveness across diverse tasks such as ranking, question answering, molecule generation, and reasoning highlights its robustness and versatility. However, PINE’s reliance on internal model mechanisms restricts its application to open-source models, and its added inference overhead may not suit efficiency-critical scenarios. Despite these limitations, PINE provides a powerful, practical solution for improving the fairness and reliability of modern language models.</p> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Shirin Tahmasebi. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?7254ae07fe9cc5f3a10843e1c0817c9c" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>