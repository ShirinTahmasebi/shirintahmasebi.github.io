<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Refine-LM | Shirin Tahmasebi </title> <meta name="author" content="Shirin Tahmasebi"> <meta name="description" content="Improving Mitigation of Language Model Stereotypes via Reinforcement Learning "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?ce48ee9bc248ee6b18f3aeefc03ed2f9"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://shirintahmasebi.github.io/bias/2023/refine_lm/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Shirin Tahmasebi </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">CV </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">Publications</a> <a class="dropdown-item " href="/background/">Background</a> </div> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Notes </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/bias/">Bias</a> <a class="dropdown-item " href="/tokenization/">Tokenization</a> <a class="dropdown-item " href="/llm_judge/">LLM as Evaluator</a> <a class="dropdown-item " href="/prompt/">Prompt Engineering</a> <a class="dropdown-item " href="/compression/">LLM Compression</a> <a class="dropdown-item " href="/agents/">LLM Agents</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/recsys/">Recommendation Systems</a> <a class="dropdown-item " href="/other/">Others</a> </div> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Refine-LM</h1> <p class="post-meta"> December 17, 2023 </p> <p class="post-tags"> <i class="fa-solid fa-calendar fa-sm"></i> 2023   ·   <i class="fa-solid fa-hashtag fa-sm"></i> bias   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"> <a href="#improving-mitigation-of-language-model-stereotypes-via-reinforcement-learning">Improving Mitigation of Language Model Stereotypes via Reinforcement Learning</a> <ul> <li class="toc-entry toc-h3"><a href="#introduction">Introduction</a></li> <li class="toc-entry toc-h3"><a href="#research-gap">Research Gap</a></li> <li class="toc-entry toc-h3"><a href="#limitations">Limitations</a></li> <li class="toc-entry toc-h3"> <a href="#solution-refine-lm">Solution: REFINE-LM</a> <ul> <li class="toc-entry toc-h4"><a href="#unqover">UnQover</a></li> <li class="toc-entry toc-h4"><a href="#refine-lm">REFINE-LM</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#conclusion">Conclusion</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <h2 id="improving-mitigation-of-language-model-stereotypes-via-reinforcement-learning"><a href="https://openreview.net/forum?id=FI8548hpZsFF" rel="external nofollow noopener" target="_blank">Improving Mitigation of Language Model Stereotypes via Reinforcement Learning</a></h2> <h3 id="introduction">Introduction</h3> <p>In recent years, Large Language Models (LLMs) have demonstrated remarkable capabilities in natural language processing tasks, yet they are prone to perpetuating societal biases, particularly in terms of gender, race, and other sensitive attributes. This has raised significant concerns about the fairness and ethical implications of deploying these models in real-world applications. Addressing these biases is critical to ensure that AI-driven systems do not reinforce stereotypes or marginalize certain groups. The REFINE-LM method represents an innovative approach to mitigating these biases by introducing a debiasing layer on top of LLMs, trained using Reinforcement Learning (RL) to adjust the model’s output probabilities and produce more equitable predictions.</p> <h3 id="research-gap">Research Gap</h3> <p>The REFINE-LM method builds on prior efforts to mitigate bias in language models by introducing a novel approach that specifically targets post-hoc adjustments to model outputs. Previous methods often required retraining entire models with additional constraints or relied on manually curated datasets, both of which can be resource-intensive and difficult to generalize across different types of biases. In contrast, REFINE-LM’s unique contribution lies in its use of RL to train a lightweight debiasing layer that operates on top of pre-trained models. This allows for real-time adjustments to token probabilities based on contextual variations, offering a more dynamic and scalable solution to bias reduction. By focusing on post-hoc corrections, REFINE-LM effectively fills the gap between resource-heavy retraining approaches and less flexible pre-processing techniques, making it a versatile tool that can be applied across various domains with minimal computational overhead.</p> <h3 id="limitations">Limitations</h3> <p>Despite the progress made with methods like REFINE-LM, there remains a substantial research gap in developing bias mitigation techniques that are effective across various types of LLM architectures, particularly for autoregressive models used in generative tasks. While REFINE-LM successfully addresses bias in masked language models, the challenge of extending such debiasing methods to generative models like GPT-3 or GPT-4, which predict text sequentially rather than filling in masked tokens, has not been fully explored. Additionally, there is a need for more comprehensive evaluations that consider a broader range of contexts and biases beyond gender and ethnicity, as well as the development of metrics that can effectively capture and quantify these biases in real-time applications.</p> <h3 id="solution-refine-lm">Solution: REFINE-LM</h3> <p>The main solution is called REFINE-LM, the overview of which is depicted in the following figure:</p> <p style="text-align:center;"><img src="/assets/img/weekly-review/refinelm_architecture.png" alt="Overview of the REFINE-LM Method" width="750" height="200"></p> <h4 id="unqover">UnQover</h4> <p>Since the paper utilizes the UnQover framework to measure bias and fairness, here’s a brief summary of the relevant concepts and metrics from that framework.</p> <p>Introduction to Symbols:</p> <ol> <li> <p>\(\tau\): A template used for testing bias, representing a sentence structure with placeholders for subjects and attributes.</p> </li> <li> <p>\(x_1, x_2\): Subjects in the template, typically representing different categories such as gender, nationality, or ethnicity.</p> </li> <li> <p>\(c\): Context within the template that provides additional information or a scenario.</p> </li> <li> <p>\(a\): Attribute in the template, which could be a stereotypical or anti-stereotypical characteristic.</p> </li> <li> <p>\(S(x\vert \tau c(a))\): The probability assigned by the language model to a subject \(x\) within the template \(\tau c(a)\).</p> </li> <li> <p>\(\neg a\): The negated attribute, representing the opposite of the stereotypical attribute.</p> </li> </ol> <p>Fairness and Bias Metrics:</p> <ol> <li> <strong>Positional Dependence (δ)</strong> <ul> <li> <strong>Purpose</strong>: Measures the sensitivity of the model’s output to the order of subjects in the template.</li> <li> <strong>Calculation</strong>: Compares the probability assigned to a subject when the order of subjects in the template is reversed.</li> <li> <strong>Formula</strong>: \(\delta(\tau c(a)) = \vert S(x_1\vert \tau c_{1,2}(a)) - S(x_1\vert \tau c_{2,1}(a))\vert\)</li> <li> <strong>Interpretation</strong>: Lower δ values indicate that the model’s predictions are less affected by the order of subjects, suggesting greater fairness.</li> </ul> </li> <li> <strong>Attributive Independence (ϵ)</strong> <ul> <li> <strong>Purpose</strong>: Assesses how much the model’s prediction for a subject is influenced by the presence of a stereotypical attribute versus its negation.</li> <li> <strong>Calculation</strong>: Compares the probability assigned to a subject in the presence of a stereotypical attribute with that in the presence of its negation.</li> <li> <strong>Formula</strong>: \(\epsilon(\tau c(a)) = \vert S(x_1\vert \tau c_{1,2}(a)) - S(x_1\vert \tau c_{1,2}(\neg a))\vert\)</li> <li> <strong>Interpretation</strong>: Lower ϵ values mean that the model’s predictions are less influenced by whether the attribute is stereotypical or not, implying greater fairness.</li> </ul> </li> <li> <strong>Subject-Attribute Bias (B)</strong> <ul> <li> <strong>Purpose</strong>: Quantifies the bias of the model towards one subject over another within the context of an attribute.</li> <li> <strong>Calculation</strong>: Averages the probabilities assigned to a subject across different template versions, considering both the original and reversed orders of the subjects.</li> <li> <strong>Formula</strong>: \(B(x_1\vert x_2, \tau c(a)) = \frac{1}{2} [S(x_1\vert \tau c_{1,2}(a)) + S(x_1\vert \tau c_{2,1}(a))] - \frac{1}{2} [S(x_2\vert \tau c_{1,2}(a)) + S(x_2\vert \tau c_{2,1}(a))]\)</li> <li> <strong>Interpretation</strong>: A bias score closer to zero indicates that the model treats the subjects more equally, which implies greater fairness.</li> </ul> </li> <li> <strong>Comparative Subject-Attribute Bias (C)</strong> <ul> <li> <strong>Purpose</strong>: Compares the bias between two subjects in different contexts to determine the direction and intensity of bias.</li> <li> <strong>Calculation</strong>: Derived from the Subject-Attribute Bias and compares the biases for each subject when their order is reversed in the template.</li> <li> <strong>Formula</strong>: \(C(\tau(a)) = \frac{1}{2} [B(x_1\vert x_2, \tau c(a)) - B(x_2\vert x_1, \tau c(a))]\)</li> <li> <strong>Interpretation</strong>: A value closer to zero suggests that the model treats both subjects more equally in the context of the attribute.</li> </ul> </li> <li> <strong>Model Bias Intensity (µ)</strong> <ul> <li> <strong>Purpose</strong>: Aggregates the bias intensities across all templates and attributes to provide an overall measure of the model’s bias.</li> <li> <strong>Calculation</strong>: The Model Bias Intensity is the average of the maximum absolute values of the subject-attribute bias (γ) across different attributes within the template set.</li> <li> <strong>Formula</strong>: \(\mu(T) = \text{avg}_{a \in A} \text{max} \, \vert \gamma(T(X_1,X_2, \{a\}))\vert\)</li> <li> <strong>Interpretation</strong>: Lower µ values indicate that the model exhibits less bias across various scenarios, reflecting overall fairness.</li> </ul> </li> </ol> <p><strong>NOTE:</strong> \(\gamma\) represents the <strong>subject-attribute bias</strong> for a particular set of templates. This metric is used to quantify the bias intensity across different combinations of subjects and attributes. More specifically, \(\gamma(T)\) is the average <strong>subject-attribute bias</strong> across all templates in a set \(T\). Given a set of templates \(T\) that contain various subjects and attributes, the subject-attribute bias \(\gamma\) is calculated as:</p> \[\gamma(T) = \text{avg}_{\tau(a) \in T} C(\tau(a))\] <h4 id="refine-lm">REFINE-LM</h4> <p>The REFINE-LM method is designed to reduce biases in the outputs of LLMs without the need for retraining the entire model. Instead, it introduces a lightweight debiasing layer on top of the LLM, which is trained using RL. This method effectively adjusts the probabilities of the model’s top predictions to produce a more fair and unbiased output.</p> <p>The key component is the debiasing layer (REFINE-LM layer), which is an additional layer added on top of the LLM. This layer takes the initial top-k token probability distribution from the LLM as input and adjusts these probabilities to reduce bias. The layer is responsible for <strong>reranking</strong> the tokens by changing their probabilities based on a policy that is learned through RL.</p> <p>The REFINE-LM layer is trained by exploring different ways to adjust the token probabilities. The RL framework helps the model learn from the feedback (rewards) and iteratively improves the layer’s ability to reduce bias.</p> <p>Once trained, the REFINE-LM layer can be applied to new inputs. It takes the initial output probabilities from the LLM, adjusts them to be less biased, and produces the final prediction.</p> <p>It is worth mentioning that, here, the contextual bandit method is used for the RL agent. So, let us have a quick overview on the main concepts:</p> <ul> <li>Context: Information that is available before making a decision. Here, it is the sentence we have in the input.</li> <li>Actions: The set of choices available. In the case of REFINE-LM, these are the adjustments made to the probabilities of the top-k tokens.</li> <li>Reward: The feedback received after taking an action. This is what we are trying to maximize. For REFINE-LM, the reward is related to how well the action reduced bias in the output.</li> <li>Policy: The REFINE-LM layer learns a policy for how to adjust the top-k token probabilities based on the observed context (the initial MLM output) to maximize fairness.</li> </ul> <p>Now, let us have an example scenario in detailed steps:</p> <p>Consider the sentence: “John got off the flight to visit Mary. [MASK] was a senator.” The LLM’s task is to predict the masked token.</p> <ol> <li> <strong>Initial LLM Prediction</strong>: The LLM generates probabilities for the top-k tokens to fill the masked position. For instance, it might output: <ul> <li>“He” — Probability: 0.50</li> <li>“She” — Probability: 0.30</li> <li>“They” — Probability: 0.10</li> <li>Other options — Probability: 0.10</li> </ul> </li> <li> <strong>Contextual Variations</strong>: To assess the robustness and fairness of these predictions, the REFINE-LM method introduces contextual variations: <ul> <li> <strong>Switching Subject Positions</strong>: The sentence is modified to “Mary got off the flight to visit John. [MASK] was a senator.”</li> <li> <strong>Negating the Context</strong>: The context might be altered to something like “[MASK] was not a senator.”</li> </ul> <p>For each variation, the LLM recalculates the probabilities:</p> <ul> <li>\(S(x_1\vert \tau c_{1,2}(a))\) — e.g., Probability for “He” in the original context.</li> <li>\(S(x_2\vert \tau c_{1,2}(a))\) — e.g., Probability for “She” in the original context.</li> <li>Probabilities are also calculated for the switched positions and negated contexts.</li> </ul> </li> <li> <p><strong>Selecting the Maximum Probability</strong>: Among all the calculated probabilities (across the different contexts), the model identifies the maximum. This maximum probability represents the model’s strongest prediction across all variations, indicating where its biases may be most pronounced.</p> </li> <li> <strong>Role of the Maximum Probability</strong>: <ul> <li> <strong>For Current Round</strong>: This maximum probability is not directly used to adjust the probability distribution in the current round of reranking by the REFINE-LM layer.</li> <li> <strong>For RL Training</strong>: The maximum probability is crucial for RL, as it is used to select the action that will determine the reward. The reward is calculated using the <strong>Comparative Subject-Attribute Bias</strong> \(C(\tau c(a))\) from the UnQover framework. \(C(\tau c(a))\) measures how the maximum probability affects the model’s bias across different contexts. This reward then informs how the REFINE-LM layer’s weights are updated, improving the policy for future rounds.</li> </ul> </li> <li> <strong>Adjusting Probabilities Using the REFINE-LM Layer</strong>: The REFINE-LM layer, guided by a policy learned through RL, adjusts the initial probabilities provided by the LLM. The goal is to reduce bias, ensuring that the final probabilities are fairer. <ul> <li>The action taken by the REFINE-LM layer involves modifying the token probabilities based on the policy, independent of the maximum probability identified for reward calculation.</li> </ul> <p><strong>Example of Adjusted Probabilities</strong>:</p> <ul> <li>“He” — Adjusted Probability: 0.35</li> <li>“She” — Adjusted Probability: 0.35</li> <li>“They” — Adjusted Probability: 0.20</li> </ul> </li> <li> <strong>Final Prediction</strong>: After adjustments, the token with the highest revised probability is selected as the final prediction. In this example, the adjusted probabilities might be: <ul> <li>“He” — Adjusted Probability: 0.35</li> <li>“She” — Adjusted Probability: 0.35</li> <li>“They” — Adjusted Probability: 0.20</li> </ul> <p>The final prediction would then reflect a less biased choice, potentially “He” or “She” depending on the exact adjustments.</p> </li> <li> <strong>Reinforcement Learning Feedback</strong>: The reward in the RL framework is calculated using \(C(\tau c(a))\), which assesses the impact of the selected action on reducing bias across various contexts. If the adjustments reduce bias effectively, this is reflected in a positive reward. The reward then guides the update of the REFINE-LM layer’s weights, improving the model’s ability to reduce bias in future predictions.</li> </ol> <h3 id="conclusion">Conclusion</h3> <p>The REFINE-LM method marks a significant advancement in the ongoing effort to reduce bias in LLMs, offering a practical and scalable solution that enhances the fairness of model outputs without requiring extensive retraining. By leveraging RL to iteratively refine the model’s predictions, REFINE-LM demonstrates that it is possible to address societal biases in AI systems proactively. However, the method’s current focus on masked language models underscores the need for further research to adapt and extend these techniques to other types of language models, ensuring that the ethical deployment of AI is upheld across all applications.</p> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Shirin Tahmasebi. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?7254ae07fe9cc5f3a10843e1c0817c9c" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>