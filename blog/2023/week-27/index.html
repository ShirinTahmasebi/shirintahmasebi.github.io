<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Paper Review - Week 27 | Shirin Tahmasebi </title> <meta name="author" content="Shirin Tahmasebi"> <meta name="description" content="Top NLP Papers Published from July 03 to July 09 "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?ce48ee9bc248ee6b18f3aeefc03ed2f9"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://shirintahmasebi.github.io/blog/2023/week-27/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Shirin Tahmasebi </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/background/">Background </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog </a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Paper Review - Week 27</h1> <p class="post-meta"> July 09, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/category/papers"> <i class="fa-solid fa-tag fa-sm"></i> papers</a>   <a href="/blog/category/weekly-review"> <i class="fa-solid fa-tag fa-sm"></i> weekly-review</a>   <a href="/blog/category/nlp"> <i class="fa-solid fa-tag fa-sm"></i> nlp</a>   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"> <a href="#genrec-large-language-model-for-generative-recommendation">GenRec: Large Language Model for Generative Recommendation</a> <ul> <li class="toc-entry toc-h3"><a href="#introduction">Introduction</a></li> <li class="toc-entry toc-h3"><a href="#research-gap">Research Gap</a></li> <li class="toc-entry toc-h3"><a href="#solution-genrec">Solution: GenRec</a></li> <li class="toc-entry toc-h3"><a href="#experiments">Experiments</a></li> <li class="toc-entry toc-h3"><a href="#conclusion">Conclusion</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#generative-job-recommendations-with-large-language-model">Generative Job Recommendations with Large Language Model</a> <ul> <li class="toc-entry toc-h3"><a href="#introduction-1">Introduction</a></li> <li class="toc-entry toc-h3"><a href="#research-gap-1">Research Gap</a></li> <li class="toc-entry toc-h3"><a href="#solution-girl">Solution: GIRL</a></li> <li class="toc-entry toc-h3"><a href="#experiments-1">Experiments</a></li> <li class="toc-entry toc-h3"><a href="#conclusion-1">Conclusion</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <p>Here is the list of the most interesting papers published in this week:</p> <ul> <li><a href="/blog/2023/week-27/#genrec-large-language-model-for-generative-recommendation">GenRec: Large Language Model for Generative Recommendation</a></li> <li><a href="/blog/2023/week-27/#generative-job-recommendations-with-large-language-model">Generative Job Recommendations with Large Language Model</a></li> </ul> <hr> <h2 id="genrec-large-language-model-for-generative-recommendation"><a href="https://arxiv.org/pdf/2307.00457.pdf" rel="external nofollow noopener" target="_blank">GenRec: Large Language Model for Generative Recommendation</a></h2> <h3 id="introduction">Introduction</h3> <p>In the rapidly evolving landscape of recommendation systems, the integration of large language models (LLMs) has emerged as a groundbreaking approach with significant potential. This paper introduces a model, GenRec, which leverages the power of LLMs for generative recommendation tasks. By directly generating target items based on comprehensive textual data understanding, GenRec demonstrates the potential of LLMs in revolutionizing the recommendation landscape.</p> <h3 id="research-gap">Research Gap</h3> <p>The paper introduces the concept of generative recommendation, wherein the target item is directly generated, in contrast to traditional discriminative recommendation systems that calculate ranking scores for each candidate item. Therefore, they proposed GenRec model, which operates as an LLM-based system that leverages textual user interaction data to provide personalized item recommendations.</p> <p><strong>Personal Opinion:</strong> However, a notable limitation of the paper is the lack of comprehensive comparison with other existing LLM-based recommendation systems. While it compares GenRec with P5, which primarily operates based on user and item IDs, the paper falls short in providing a thorough analysis and comparison with other state-of-the-art LLM-based recommendation models that incorporate textual information. Also, since its focus is on generative recommendation task, it was better to mention the hallucination problem as well.</p> <h3 id="solution-genrec">Solution: GenRec</h3> <p>GenRec primarily leverages an LLM to generate the next recommended item based on a formatted prompt. This prompt consists of three parts:</p> <ul> <li> <p><strong>Instruction:</strong> A fixed template for each recommendation task that provides specific guidance to the LLM regarding the nature and context of the recommendation task.</p> </li> <li> <p><strong>Input:</strong> Concatenation of the names of the items with which the user has previously interacted. This historical interaction data serves to provide context to the LLM, allowing it to understand the user’s preferences and behavior.</p> </li> <li> <p><strong>Output:</strong> A segment left for the LLM to complete, representing the predicted next item for the user to interact with. The LLM’s understanding of the user’s preferences and historical interactions enables it to generate informed recommendations for the user.</p> </li> </ul> <p>While the GenRec model utilizes the LLaMA large language model as its backbone, it is not limited to any specific LLM. This flexibility allows for the adaptation of the GenRec approach to various LLMs, depending on the specific requirements and context of the recommendation task at hand.</p> <p>Here is a brief overview of the architecture of GenRec:</p> <p style="text-align:center;"><img src="/assets/img/weekly-review/genrec_architecture.png" alt="The Architecture" width="650" height="300"></p> <p>This is an example of the formatted prompt in GenRec:</p> <p style="text-align:center;"><img src="/assets/img/weekly-review/genrec_example_input.png" alt="The Architecture" width="650" height="300"></p> <h3 id="experiments">Experiments</h3> <p>The experiments conducted in the paper aimed to evaluate the performance of the proposed recommendation system, GenRec, in sequential recommendation. The primary aspects of the experimental setup are outlined below:</p> <ul> <li> <strong>Datasets:</strong> The experiments were performed on two real-world datasets - the Amazon Toys dataset and the MovieLens-25M dataset.</li> <li> <strong>Baseline Methods:</strong> The paper compared the performance of the GenRec model with the P5 model, which operates based on user and item IDs.</li> <li> <strong>Evaluation Metrics:</strong> The evaluation metrics utilized are Hit Ratio (HR), Normalized Discounted Cumulative Gain (NDCG). Also, the core LLM used in GenRec is LLaMA.</li> <li> <strong>Results:</strong> While P5 showed better performance on the Amazon Toys dataset, the GenRec model exhibited significantly improved results on the MovieLens 25M dataset.</li> </ul> <h3 id="conclusion">Conclusion</h3> <p>In conclusion, the GenRec model presents an LLM-based recommendation system. By effectively leveraging the rich contextual information embedded within LLMs, GenRec provides a reasonably accurate and personalized recommendations.</p> <h2 id="generative-job-recommendations-with-large-language-model"><a href="https://arxiv.org/pdf/2307.02157.pdf" rel="external nofollow noopener" target="_blank">Generative Job Recommendations with Large Language Model</a></h2> <h3 id="introduction-1">Introduction</h3> <p>In the ever-evolving landscape of job marketplaces, the need for efficient and accurate job recommendation systems has become paramount. Traditional approaches often rely on discriminative models that match job seekers with available positions based on predefined criteria. However, the growing complexity of user preferences and job requirements demands a more sophisticated and interactive approach. To address these challenges, they propose a novel framework called Generative Interactive Reinforcement Learning (GIRL) for job recommendation. GIRL leverages the power of large language models and reinforcement learning techniques to generate high-quality job descriptions and optimize recommendations based on user preferences, thereby enhancing the overall efficiency and effectiveness of the job recommendation process.</p> <h3 id="research-gap-1">Research Gap</h3> <p>This paper addresses several critical gaps in the existing job recommendation systems. Some of these gaps include:</p> <ul> <li> <strong>Lack of Explainability:</strong> Many existing job recommendation systems operate as “black-box” models, meaning they lack transparency in how they provide recommendations. So, the authors address this problem by leveraging LLMs to generate job descriptions based on the candidates’ CVs. By utilizing LLMs, the system can offer detailed and coherent job recommendations that are easily understandable to the job seekers.</li> <li> <strong>Limitations of Traditional Models:</strong> Traditional job recommendation models often focus on collaborative filtering or person-job matching strategies. While these methods are effective to a certain extent, they are limited in their ability to offer comprehensive career guidance. To address this problem, instead of relying solely on collaborative filtering or person-job matching, they proposed a novel <em>generative</em> approach..</li> <li> <strong>Semantic Gap between CVs and JDs:</strong> The existence of a significant semantic gap between the information in candidates’ CVs and the requirements in JDs results in underwhelming performance for traditional methods. This gap makes it challenging to match job seekers with their ideal positions effectively. In this paper, by utilizing LLMs and the proposed training methodology, the GIRL framework effectively bridges the semantic gap between CVs and JDs.</li> </ul> <h3 id="solution-girl">Solution: GIRL</h3> <p>GIRL is composed of three steps. These steps are described as follows:</p> <ul> <li> <p><strong>Supervised Fine-Tuning:</strong> In the first step, the aim is to train a LLM-based generative model based on supervised learning. Specifically, the model is trained to generate suitable Job Descriptions (JDs) based on the given Curriculum Vitae (CV) of a job seeker. The inputs to the generative model include the CV of the job seeker and a prompt template that describes the generation task using natural language. The output of the model is the generated Job Description (JD) that is tailored to the specific job seeker’s profile.Now let us clarify how this LLM-based generation model is trained and used in the inference time.During the <em>training phase</em>, the model is provided with pairs of CVs and their corresponding matched job descriptions. These pairs are used to create prompts that contain information from both the CV and the existing job description. The LLM-based generator is trained to generate job descriptions that align with the information provided in the prompts. The negative log likelihood serves as the loss function, which measures the dissimilarity between the generated job description and the one provided in the prompt. This loss function guides the training process, helping the model learn to generate more accurate and contextually relevant job descriptions.During the <em>inference time</em>, the trained model receives only the CV, which represents the job seeker’s profile, and it is expected to generate a suitable job description based on the learned patterns from the training data. This process ensures that the model can provide personalized and relevant job recommendations based solely on the input of the job seeker’s CV during real-world use.</p> </li> <li> <p><strong>Reward Model Training:</strong> In the second step of the GIRL framework, the main objective is to train a reward model that evaluates the matching degree between the CV and JD pairs. During the <em>training phase</em>, the reward model receives both positive pairs, where the CV and JD are a good match, and negative pairs, where the CV and JD do not match well. This information is used to train the reward model to distinguish between suitable and unsuitable CV-JD combinations. The pairwise ranking loss function is employed to guide the training of the reward model. This loss function helps the model learn to differentiate between positive and negative pairs effectively, contributing to its ability to accurately assess the compatibility between CVs and JDs.During the <em>inference phase</em>, the trained reward model can receive a CV and a JD pair and provide a matching score indicating the extent to which the CV and JD align. This matching score serves as an indicator of the suitability of the job for the specific job seeker, allowing for the evaluation and assessment of potential job matches.</p> </li> <li> <p><strong>Reinforcement Learning Phase:</strong> The third step in the GIRL framework involves aligning the generator model and the reward model using a reinforcement learning approach. This step serves the purpose of fine-tuning the generator’s output to better match the preferences and requirements of recruiters or employers, ensuring that the generated job descriptions are not only suitable for the job seekers but also cater to the practical demands of the job market.Alignment, in this context, refers to the process of adjusting the parameters and behavior of the generator model based on the feedback received from the reward model, which evaluates the quality of the generated job descriptions. By using reinforcement learning techniques such as Proximal Policy Optimization (PPO), the generator can learn to produce job descriptions that not only reflect the characteristics of the job seekers but also align with the expectations and preferences of employers, as captured by the feedback provided to the reward model.</p> </li> </ul> <p>So, in summary, about the connection between these three steps, we can say that:</p> <ul> <li>In the first step, the job descriptions are generated solely based on the information contained in the CVs of the job seekers. This step ensures that the generated job descriptions are tailored to the specific characteristics and preferences of the job seekers.</li> <li>In the second step, the system considers the feedback from the employers, allowing the model to discern whether a particular job seeker’s CV aligns well with the job description, as perceived by the employers. This step introduces a crucial dimension where the compatibility between the CV and the job description is evaluated based on the feedback from the employers, making the recommendation process more comprehensive.</li> <li>The third step then takes the learning from the second step and utilizes reinforcement learning techniques to further align the generated job descriptions with the preferences and expectations of the employers. This step ensures that the generator model in the first step is continuously fine-tuned to produce job descriptions that not only match the job seeker’s characteristics but also resonate more closely with the preferences and requirements of the employers.</li> </ul> <p style="text-align:center;"><img src="/assets/img/weekly-review/girl_architecture.png" alt="The Architecture" width="750" height="300"></p> <h3 id="experiments-1">Experiments</h3> <p>The primary aspects of the experimental setup are outlined below:</p> <ul> <li> <strong>Datasets:</strong> The datasets used in this paper comes from one of the largest online recruitment platform in China. In this platform, each job seeker has a CV, encompassing their basic demographic information, educational background, and work experience. Meanwhile, each job is associated with a JD, detailing the responsibilities of the role, the compensation package, and etc.</li> <li> <strong>Baseline Methods:</strong> It seems that the evaluation focused on comparing different components or variations of their proposed GIRL approach against specific models or variants. Instead of completely replacing the entire system, they compared the performance of different elements and configurations within their GIRL approach, such as comparing the performance of GIRL with GIRL-SFT and other LLMs for the generation quality evaluation.</li> </ul> <h3 id="conclusion-1">Conclusion</h3> <p>In this paper, the authors introduced the GIRL framework, a novel approach for job recommendation that combines generative models with reinforcement learning techniques. Through our comprehensive evaluation, we demonstrated the effectiveness of the GIRL approach in generating high-quality job descriptions and enhancing the performance of traditional recommendation systems. By leveraging the power of large language models and reinforcement learning, they were able to bridge the gap between job seekers and employers, providing more accurate and personalized job recommendations.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <p class="mb-2">Here are some more articles relevant to this one:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/week-25/">Paper Review - Week 25</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/week-23/">Paper Review - Week 23</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/week-46/">Paper Review - Week 46</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/week-10/">Paper Review - Week 10</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/week-35/">Paper Review - Week 35</a> </li> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Shirin Tahmasebi. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?7254ae07fe9cc5f3a10843e1c0817c9c" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>