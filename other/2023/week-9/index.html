<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Paper Review - Week 9 | Shirin Tahmasebi </title> <meta name="author" content="Shirin Tahmasebi"> <meta name="description" content="Top NLP Papers Published from February 27 to March 05 "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?ce48ee9bc248ee6b18f3aeefc03ed2f9"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://shirintahmasebi.github.io/other/2023/week-9/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Shirin Tahmasebi </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">CV </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">Publications</a> <a class="dropdown-item " href="/background/">Background</a> </div> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Notes </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/bias/">Bias</a> <a class="dropdown-item " href="/tokenization/">Tokenization</a> <a class="dropdown-item " href="/llm_judge/">LLM as Evaluator</a> <a class="dropdown-item " href="/prompt/">Prompt Engineering</a> <a class="dropdown-item " href="/compression/">LLM Compression</a> <a class="dropdown-item " href="/agents/">LLM Agents</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/recsys/">Recommendation Systems</a> <a class="dropdown-item " href="/other/">Others</a> </div> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Paper Review - Week 9</h1> <p class="post-meta"> March 05, 2023 </p> <p class="post-tags"> <i class="fa-solid fa-calendar fa-sm"></i> 2023   ·   <i class="fa-solid fa-tag fa-sm"></i> papers   <i class="fa-solid fa-tag fa-sm"></i> weekly-review   <i class="fa-solid fa-tag fa-sm"></i> nlp   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"> <a href="#reward-design-with-language-models">Reward Design with Language Models</a> <ul> <li class="toc-entry toc-h3"><a href="#introduction">Introduction</a></li> <li class="toc-entry toc-h3"><a href="#research-gap">Research Gap</a></li> <li class="toc-entry toc-h3"><a href="#solution">Solution</a></li> <li class="toc-entry toc-h3"> <a href="#experiments">Experiments</a> <ul> <li class="toc-entry toc-h4"><a href="#overall-performance">Overall Performance</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#conclusion">Conclusion</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#mathprompter">MathPrompter</a></li> <li class="toc-entry toc-h2"> <a href="#llama-open-and-efficient-foundation-language-models">LLaMA: Open and Efficient Foundation Language Models</a> <ul> <li class="toc-entry toc-h3"><a href="#training-datasets">Training Datasets</a></li> <li class="toc-entry toc-h3"><a href="#architecture">Architecture</a></li> <li class="toc-entry toc-h3"><a href="#performance">Performance</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <p>To me, the most interesting papers among those published in this week are:</p> <ul> <li><a href="/blog/2023/week-9/#reward-design-with-language-models">Reward Design with Language Models</a></li> <li><a href="/blog/2023/week-9/#mathprompter">MathPrompter: Mathematical Reasoning Using Large Langugage Models</a></li> <li><a href="/blog/2023/week-9/#llama-open-and-efficient-foundation-language-models">LLaMA: Open and Efficient Foundation Language Models</a></li> </ul> <hr> <h2 id="reward-design-with-language-models"><a href="https://arxiv.org/pdf/2303.00001" rel="external nofollow noopener" target="_blank">Reward Design with Language Models</a></h2> <h3 id="introduction">Introduction</h3> <p>This paper introduces a novel approach to reward function design in Reinforcement Learning (RL) by leveraging Large Language Models (LLMs) such as GPT-3. Traditional methods of designing reward functions involve either manually crafting complex functions or collecting extensive labeled data, both of which can be challenging and impractical. The authors propose using LLMs as proxy reward functions, allowing users to specify desired behaviors through natural language prompts. By evaluating the agent’s behavior against these user-specified objectives, the LLM provides textual feedback that is converted into numerical rewards for training the RL agent. This approach aims to simplify the reward design process, making it more intuitive and efficient, and to improve the alignment of RL agent behavior with user objectives.</p> <h3 id="research-gap">Research Gap</h3> <p>Designing effective reward functions is a critical and challenging aspect of RL. Traditional approaches to reward design often involve manually crafting reward functions or collecting large amounts of labeled data to train supervised models. These methods have several difficulties: they require deep domain knowledge, are susceptible to reward hacking, and do not generalize well to new tasks or user preferences. Moreover, creating reward functions that balance multiple objectives is notoriously complex, and the extensive data requirements for supervised learning models make this process costly and time-consuming. This paper addresses these significant gaps by proposing an innovative method that leverages LLMs such as GPT-3 as proxy reward functions.</p> <p>Advantages of the Proposed Method:</p> <ol> <li> <p><strong>Simplified Reward Design</strong>: The use of natural language prompts allows users to specify desired behaviors in an intuitive and accessible manner. This removes the need for expert-level knowledge in crafting complex reward functions.</p> </li> <li> <p><strong>Data Efficiency</strong>: The LLM-based approach demonstrates superior data efficiency by requiring only a few examples (few-shot prompting) or even zero examples (zero-shot prompting) to generate effective reward signals. This significantly reduces the cost and effort associated with collecting extensive labeled data.</p> </li> <li> <p><strong>Flexibility and Generalization</strong>: LLMs are pre-trained on vast amounts of internet-scale text data, enabling them to generalize well across different tasks and user objectives. This flexibility allows for broader applicability and adaptability to new environments without needing to redesign reward functions or collect new data.</p> </li> <li> <p><strong>Mitigation of Reward Hacking</strong>: By leveraging the extensive pre-trained knowledge of LLMs, the approach can provide more accurate and contextually appropriate reward signals, reducing the likelihood of reward hacking where agents exploit poorly designed reward functions.</p> </li> <li> <p><strong>Improved Alignment with User Objectives</strong>: The LLM-based method has shown to better align RL agent behavior with user-specified objectives compared to traditional supervised learning models. This results in RL agents that perform more in line with the nuanced preferences of users.</p> </li> <li> <p><strong>Robust Evaluation and Performance</strong>: Experimental results across diverse tasks, such as the Ultimatum Game, Matrix Games, and the DEALORNODEAL negotiation task, demonstrate the effectiveness of the LLM-based approach in providing high labeling accuracy and better RL agent performance.</p> </li> </ol> <h3 id="solution">Solution</h3> <p>This paper explores an innovative approach to designing reward functions for training RL agents. This method leverages LLMs like GPT-3 to simplify the reward design process, making it more intuitive and efficient. Here’s a detailed summary of their method:</p> <ol> <li> <strong>Objective Specification via Prompts</strong>: <ul> <li>Users specify the desired behavior of the RL agent through natural language prompts. These can include a few examples of the behavior (few-shot prompting) or a description of the behavior (zero-shot prompting).</li> </ul> </li> <li> <strong>Role of the LLM</strong>: <ul> <li>The LLM acts as a proxy reward function. It evaluates the agent’s behavior against the user’s objectives, expressed in natural language, and provides a textual evaluation (e.g., yes/no or a score).</li> <li>The LLM’s evaluation is converted into a numerical reward signal using handcrafted parsers, which is then used to train the RL agent.</li> </ul> </li> <li> <strong>Training Phase</strong>: <ul> <li>The RL agent generates behaviors by interacting with the environment.</li> <li>The LLM evaluates these behaviors based on the user-specified objectives and provides corresponding reward signals.</li> <li>The RL agent updates its policy using these reward signals, iteratively refining its behavior to align with the user’s objectives.</li> </ul> </li> <li> <strong>Inference Phase</strong>: <ul> <li>Once the RL agent is trained, it uses the learned policy to operate independently in the environment without further input from the LLM.</li> <li>The LLM is not involved in the inference phase; the RL agent acts autonomously based on its training.</li> </ul> </li> <li> <strong>Evaluation and Baselines</strong>: <ul> <li>The effectiveness of the LLM-based reward design is evaluated against traditional approaches: <ul> <li> <strong>Supervised Learning (SL) Baseline</strong>: A supervised learning model is trained on labeled examples to predict rewards. The LLM is used to generate these examples in a few-shot setting. This SL model then predicts reward signals for the RL agent based on these examples.</li> <li> <strong>No Objective Baseline</strong>: Uses the LLM without specific user objectives to see how well it generalizes.</li> <li> <strong>Ground Truth Reward Functions</strong>: Uses predefined, ideal reward functions directly encoding user objectives as a benchmark.</li> </ul> </li> <li>Performance metrics include labeling accuracy (how well the reward signals match ground truth) and RL agent accuracy (how well the agent’s behavior aligns with user objectives).</li> </ul> </li> </ol> <p>Their proposed solution for training the RL agent is also depicted in this figure:</p> <figure style="text-align:center;"> <img src="/assets/img/weekly-review/reward_design_llm.png" alt="The Architecture" width="400" height="350"> <figcaption>Figure 2. Mixtral Architecture</figcaption> </figure> <h3 id="experiments">Experiments</h3> <p>They evaluate the effectiveness of LLM-based reward design through a series of experiments across different tasks. Here’s a summary of the tasks used, a brief explanation of each, and the performance of the models in each task:</p> <ol> <li> <strong>Ultimatum Game</strong>: <ul> <li> <strong>Description</strong>: The Ultimatum Game involves two players, a Proposer and a Responder. The Proposer suggests a split of a sum of money, and the Responder can either accept or reject it. If the Responder accepts, both players get the proposed amounts; if rejected, both get nothing.</li> <li> <strong>Objective</strong>: Train an RL agent (Responder) to align with user-specified preferences for accepting or rejecting proposals.</li> <li> <strong>Results</strong>: <ul> <li> <strong>Labeling Accuracy</strong>: The LLM-based approach maintained high labeling accuracy with both 10 examples and a single example with an explanation.</li> <li> <strong>RL Agent Accuracy</strong>: The RL agents trained with LLM-generated rewards showed higher accuracy in aligning with user preferences compared to those trained with the SL baseline.</li> </ul> </li> </ul> </li> <li> <strong>Matrix Games</strong>: <ul> <li> <strong>Description</strong>: This task involves two-player normal-form games like Battle of the Sexes, Stag Hunt, Chicken, and Prisoner’s Dilemma. Each game consists of a single timestep with discrete actions leading to joint outcomes and rewards.</li> <li> <strong>Objective</strong>: Evaluate the ability of the LLM to provide reward signals based on well-known solution concepts like total welfare, equality, Rawlsian fairness, and Pareto-optimality.</li> <li> <strong>Results</strong>: <ul> <li> <strong>Labeling Accuracy</strong>: The LLM-based approach significantly improved labeling accuracy over the No Objective baseline, particularly when using zero-shot prompting.</li> <li> <strong>RL Agent Accuracy</strong>: RL agents trained with LLM-generated rewards achieved high accuracy in meeting the objectives, often outperforming the No Objective baseline.</li> </ul> </li> </ul> </li> <li> <strong>DEALORNODEAL Negotiation Task</strong>: <ul> <li> <strong>Description</strong>: This long-horizon task involves a negotiation between two agents, Alice and Bob, over the allocation of a set of objects (books, hats, and balls). The agents propose and counter-propose allocations until an agreement is reached or the negotiation fails.</li> <li> <strong>Objective</strong>: Train Alice to negotiate in styles specified by the user, such as versatile, push-over, competitive, and stubborn behaviors.</li> <li> <strong>Results</strong>: <ul> <li> <strong>Labeling Accuracy</strong>: The LLM-based approach generally outperformed the SL baseline, especially for styles like competitive and stubborn.</li> <li> <strong>RL Agent Accuracy</strong>: RL agents trained with LLM-generated rewards better aligned with user-specified negotiation styles compared to those trained with SL. A pilot user study also confirmed that users rated LLM-trained agents as more aligned with their preferred styles.</li> </ul> </li> </ul> </li> </ol> <h4 id="overall-performance">Overall Performance</h4> <ul> <li> <strong>Labeling Accuracy</strong>: The LLM-based reward design consistently showed high labeling accuracy, indicating that the LLM could effectively generate reward signals aligned with user objectives.</li> <li> <strong>RL Agent Accuracy</strong>: RL agents trained with LLM-generated rewards performed better in aligning their behavior with user objectives across all tasks compared to traditional baselines.</li> <li> <strong>Data Efficiency</strong>: The LLM-based approach demonstrated superior data efficiency, achieving high performance with fewer examples compared to supervised learning models.</li> <li> <strong>Flexibility and Robustness</strong>: The approach generalized well across different tasks and objectives, showcasing the flexibility and robustness of using LLMs for reward design.</li> </ul> <h3 id="conclusion">Conclusion</h3> <p>The experimental results demonstrate that the LLM-based reward design significantly outperforms traditional approaches in various tasks, including the Ultimatum Game, Matrix Games, and the DEALORNODEAL negotiation task. The LLM-based method showed higher labeling accuracy and better alignment of RL agent behavior with user objectives, while also proving to be more data-efficient. Additionally, the method exhibited robust generalization across different tasks and objectives. Overall, the study highlights the potential of using LLMs to streamline and enhance reward design in RL, providing a flexible and effective solution for training objective-aligned agents.</p> <h2 id="mathprompter"><a href="https://arxiv.org/pdf/2303.05398.pdf" rel="external nofollow noopener" target="_blank">MathPrompter</a></h2> <p>This paper focuses on using LLMs for mathematical reasoning. Some of the challenges in this work are as follows:</p> <ul> <li>Mathematical operations usually have a single correct answer.</li> <li>Not only the final output is important, the procedure and the intermidate steps that resulted into that final output should also be correct.</li> <li>It is difficult to ensure that the generated output and the intermediate steps are all correct. In other words, it is better to have a metric to show that how much the model is confident about the generated output!</li> </ul> <p>Accordingly, MathPrompter tries to propose a solution to increase the validity and reliability of mathematical reasoning using LLMs. Their solution is to simulate the usual approach that studnets usually take for solving a math problem. So, the steps in MathPrompter is as follows:</p> <ol> <li>Receiving the definition of a mathematical problem as text. For example: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>At a restaurant, each adult meal costs $5 and kids eat free. If a group of 15 people came in and 8 were kids, how much would it cost for the group to eat? 
</code></pre></div> </div> </li> <li>Generating a template for the input question and creating a list of values for solving the template: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Template = At a restaurant, each adult meal costs A and kids eat free. if a group of B people came in and C were kids, how much would it cost for the group to eat?
Mapping = {A:5, B:15, C:8}
</code></pre></div> </div> </li> <li>Creaing proper prompts for creating different solutions. For example, one solution can be a python function and the other can be a algebraic equation. So, by providing these prompts to the LLM: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Algebraic prompt: Write a mathematical equation and generate the answer format starting with ‘Answer =’
Python prompt: Write a Python function that returns the answer.
</code></pre></div> </div> <p>then, the LLM is supposed to generated the two following outputs:</p> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1"># Algebraic expression output
</span><span class="n">Answer</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="n">C</span><span class="p">)</span>
<span class="c1"># Python expression output
</span><span class="k">def</span> <span class="nf">total_price</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">A</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="n">C</span><span class="p">)</span>
</code></pre></div> </div> <p>These outputs can help the user to have an insight about how the LLM is reasoning.</p> </li> <li>Then, MathPrompter uses different randomized values for \(A\), \(B\), and \(C\). Then, it passes all the randomized values to the both outpus. If, for more than 5 times, the result of the two outputs (algebraic and python expression) are the same, then both of them are accepted as the correct solutions for the mathematical problem.</li> </ol> <p>This is definitely a very interesting and novel idea. However, I personally have some concerns about it:</p> <ol> <li>First of all, MathPrompter is not making it easier for LLMs to find a solution. The only thing that it does is to ask LLMs to generate multiple outputs, such as algebraic and python expression.</li> <li>MathPrompter uses several randomized values (at least 5 values) to validate if the LLM outputs result in the same number or not. However, it is not clear that how these randomized values are generated. If users are supposed to provide these values, then I think it somehow makes the LLM useless here! Because users need to solve the problem themselves to be able to provide such values. So, in this case, they don’t need LLMs anymore! :)</li> <li>If for the specific values in the input mathematical problem, algebraic and python expressions result in different values, then what can be reported to the user?</li> </ol> <h2 id="llama-open-and-efficient-foundation-language-models"><a href="https://arxiv.org/pdf/2302.13971.pdf" rel="external nofollow noopener" target="_blank">LLaMA: Open and Efficient Foundation Language Models</a></h2> <p>Recently, the trend of novel language models is that they are becomming larger and larger. The main idea behind this trend is that, probabely, by increasing the number of parameters of a language model, it can have a better performance. In other words, the prevalent idea is that, the larger the model, the better the performance.</p> <p>However, a paper, published in 2022, tried to challange this idea. They hypothesised that it is not only the size of the language models which make their quality better. There is another very important aspect: <strong>the size of the training data</strong>. This hypothesis, which is also known as the <strong>Hoffmann’s Scaling Law</strong>, has been the foundation of one of the recenly-proposed language models, named <strong>Chinchilla</strong>. Chinchilla has only 70B parameter (compared to GPT-3 with about 175B parameter) and can still get comparable performance to GPT-3.</p> <p>LLaMa is another novel language model which uses the Hoffmann’s scaling law as its foundation. It has several variants, each of which with different number of parameter–ranging from 7B to 65B parameter. Although the size of the model is significantly smaller than GPT-3, it has comparable results to GPT-3 for most downstream task; and even for some of the downstream tasks, it can outperform GPT-3.</p> <p>Now, to investigate the specific charactristics of LLaMa, we look at its three aspects:</p> <ol> <li>Training Datasets</li> <li>Architecture</li> <li>Performance</li> </ol> <h3 id="training-datasets">Training Datasets</h3> <p>As mentioned previously, LLaMa is supposed to have between 7B and 65B parameters. To this end, according to the Hoffmann’s scaling law, the training dataset consist of 14 Trillion tokens. To collect this 14 Trillion tokens, the following datasets are used:</p> <ul> <li>English CommonCrawl [67%]: Public crawled web pages from 2017 to 2020</li> <li>C4 [15%]: Preprocessed CommonCrawl!</li> <li>Github [4.5%]</li> <li>Wikipedia [4.5%]: Covering 20 languages from June 2022 to August 2022</li> <li>Gutenberg and Books3 [4.5%]: Two book corpora from public domain</li> <li>ArXiv [2.5%]</li> <li>Stack Exchange [2%]: From 28 topics</li> </ul> <h3 id="architecture">Architecture</h3> <p>LLaMa is a transformer-based model. However, instead of using the main transformer building block as it is, they apply several minor changes to it. These changes are mainly for reducing the training time. The changes are as follows:</p> <ul> <li>Pre-normalization instead of post-normalization</li> <li>Activation function from ReLU to SwiGLU</li> <li>Positional encoding from absolute to Rotary</li> </ul> <p>The following image represents how the architecture looks like after applying the above changes. The image on the left shows the usual transformer building block and the one on the right illustrates the building block after applying the changes.</p> <p style="text-align:center;"><img src="/assets/img/weekly-review/llama_architecture_building_block.png" alt="Candidate Generation Approaches" width="800" height="400"></p> <h3 id="performance">Performance</h3> <p>They have evaluated LLaMa on different tasks and compared it with the two of the recent extremely large language models. The results are as the following:</p> <ul> <li>Common Sense Reading <ul> <li>Evaluated in zero-shot setting.</li> <li> <strong>LLaMa (65B)</strong> <em>outperforms</em> <strong>Chinchilla (70B)</strong>.</li> <li> <strong>LLaMa (65B)</strong> <em>outperforms</em> <strong>PaLM (540B)</strong> and <strong>GPT-3 (175B)</strong> on most datasets.</li> </ul> </li> <li>Closed-book Question Answering <ul> <li>Evaluated in zero-shot and few-shot settings.</li> <li> <strong>LLaMa (13B)</strong> is <em>competitive</em> with <strong>GPT-3 (175B)</strong> and <strong>Chinchilla (70B)</strong>.</li> <li> <strong>LLaMa (65B)</strong> <em>outperforms</em> <strong>PaLM (540B)</strong>, <strong>GPT-3 (175B)</strong>, and <strong>Chinchilla (70B)</strong>.</li> </ul> </li> <li>Reading Comprehension <ul> <li>Evaluated in zero-shot setting.</li> <li> <strong>LLaMa (65B)</strong> is <em>competitive</em> with <strong>PaLM (540B)</strong>.</li> <li> <strong>LLaMa (13B)</strong> <em>outperforms</em> <strong>GPT-3 (175B)</strong>.</li> </ul> </li> <li>Mathematical Reasoning <ul> <li> <strong>LLaMa (65B)</strong> <em>outperforms</em> <strong>PaLM (540B)</strong>.</li> </ul> </li> </ul> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Shirin Tahmasebi. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?7254ae07fe9cc5f3a10843e1c0817c9c" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>