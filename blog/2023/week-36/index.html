<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Paper Review - Week 36 | Shirin Tahmasebi </title> <meta name="author" content="Shirin Tahmasebi"> <meta name="description" content="Top NLP Papers Published from September 04 to September 10 "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?ce48ee9bc248ee6b18f3aeefc03ed2f9"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://shirintahmasebi.github.io/blog/2023/week-36/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Shirin Tahmasebi </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog </a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Paper Review - Week 36</h1> <p class="post-meta"> September 10, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/category/papers"> <i class="fa-solid fa-tag fa-sm"></i> papers</a>   <a href="/blog/category/weekly-review"> <i class="fa-solid fa-tag fa-sm"></i> weekly-review</a>   <a href="/blog/category/nlp"> <i class="fa-solid fa-tag fa-sm"></i> nlp</a>   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"> <a href="#large-language-models-as-optimizers">Large Language Models as Optimizers</a> <ul> <li class="toc-entry toc-h3"><a href="#introduction">Introduction</a></li> <li class="toc-entry toc-h3"><a href="#research-gap">Research Gap</a></li> <li class="toc-entry toc-h3"><a href="#solution-orpo-framework">Solution: ORPO Framework</a></li> <li class="toc-entry toc-h3"><a href="#experiments">Experiments</a></li> <li class="toc-entry toc-h3"><a href="#conclusion">Conclusion</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <p>Here is the list of the most interesting papers published in this week:</p> <ul> <li><a href="/blog/2023/week-36/#large-language-models-as-optimizers">Large Language Models as Optimizers</a></li> </ul> <hr> <h2 id="large-language-models-as-optimizers"><a href="https://arxiv.org/pdf/2309.03409.pdf" rel="external nofollow noopener" target="_blank">Large Language Models as Optimizers</a></h2> <h3 id="introduction">Introduction</h3> <p>In this paper, the authors are using LLMs to solve optimization problems. The fundamental idea is to use optimized prompts as input for the language model, rather than explicitly constructing complex mathematical models or relying on conventional solvers like CPLEX or Gurobi. This inspiring approach simplifies how optimization problems are presented to the model, providing flexibility and reducing the requirement for domain-specific expertise. It also demonstrates that language models can effectively handle diverse optimization problems and may outperform traditional heuristic methods in certain cases.</p> <h3 id="research-gap">Research Gap</h3> <p>The advantages of using LLMs for such purpose can be considered as follows:</p> <ul> <li>By using optimized prompts, the need for creating complex mathematical models or constraints for optimization problems is reduced. This simplifies the way optimization problems are presented to the model.</li> <li>Solving complex optimization problems requires expertise in both the problem domain and optimization techniques. Using language models with optimized prompts potentially requires less domain-specific knowledge, making optimization more accessible.</li> <li>The authors also demonstrate that LLMs can perform well on various optimization problems, even outperforming traditional heuristic approaches in some cases.</li> <li>The optimized prompts found for one problem can sometimes be applied to similar problems, as demonstrated in the transferability experiments.</li> </ul> <p>Generally, the authors demonstrated that using LLMs with optimized prompts is a promising approach for addressing optimization problems, offering simplicity, flexibility, and potential benefits over traditional methods. However, it’s important to note that this approach might not be suitable for all optimization problems and has its own limitations, as mentioned in the research.</p> <h3 id="solution-orpo-framework">Solution: ORPO Framework</h3> <p>The researchers propose a framework named OPRO. In this framework, they create a meta-prompt. The meta-prompt consists of two key components:</p> <ul> <li>Task Description: This part of the meta-prompt provides a description of the optimization problem to be solved. It typically includes problem-specific details.</li> <li>Generated Prompts and Corresponding Accuracy Pairs: This part consists of pairs of generated prompts (candidate instructions) and their corresponding accuracy scores. These prompts are generated by the language model during the optimization process. They represent potential instructions for solving the problem.</li> </ul> <p style="text-align:center;"><img src="/assets/img/weekly-review/orpo_framework_architecture.png" alt="The Architecture" width="350" height="400"></p> <p>Now, we can review the whole optimization process and its steps; To make the whole process as clear as possible, let us leverage an example. Let us say we have an optimization problem related to scheduling a set of tasks. So, we want to find the most efficient way to assign these tasks to workers while minimizing the overall time taken.</p> <p><strong>Step 1:</strong> The optimization process is initiated by providing the meta-prompt to an LLM. As mentioned earlier the meta-prompt contains two parts: task description and generated prompts and their corresponding accuracy pair. For example, the meta prompt can be:</p> <ul> <li>Task Description: You need to assign these tasks to workers while minimizing the total time taken. The tasks have different durations and dependencies.</li> <li>Pairs of Prompts and Their Accuracy: <ul> <li>“Minimize time by finding the optimal task assignment.” (Prompt) - 80% accuracy</li> <li>“Distribute tasks efficiently to reduce total time.” (Prompt) - 75% accuracy</li> <li>“Schedule tasks to minimize the overall duration.” (Prompt) - 85% accuracy</li> </ul> </li> </ul> <p>The LLM takes in the entire context, including the task description and the pairs of prompts and accuracy scores. It uses the information in the meta-prompt to generate instructions and attempts to solve the optimization problem. For example, let us assume that the LLM generate the following instruction and solution:</p> <ul> <li>Instruction: Optimize the task assignment for minimal time.</li> <li>Solution: Assign task A to worker 1, task B to worker 2, and task C to worker 3 for the shortest completion time.</li> </ul> <p><strong>Step 2:</strong> Now, the generated solution should be evaluated to measure its accuracy. The accuracy of the provided solution is typically measured by comparing it to the known or optimal solution for the given optimization problem. If the problem is a mathematical optimization task, accuracy could be determined by calculating the error or the deviation of the LLM’s solution from the known optimal solution. For example, if the LLM is solving the Traveling Salesman Problem, accuracy could be measured as the percentage difference between the length of the path found by the LLM and the length of the shortest path possible. The smaller the difference, the higher the accuracy. Let us say that, in our example, the accuracy is 87%.</p> <p><strong>Step 3:</strong> The pair of the LLM-generated prompt and its corresponding accuracy score is added to the meta-prompt. In each optimization step, this new information is appended to the existing meta-prompt. So, here, the updated meta-prompt would be:</p> <ul> <li>Task Description: You need to assign these tasks to workers while minimizing the total time taken. The tasks have different durations and dependencies.</li> <li>Pairs of Prompts and Their Accuracy: <ul> <li>“Minimize time by finding the optimal task assignment.” (Prompt) - 80% accuracy</li> <li>“Distribute tasks efficiently to reduce total time.” (Prompt) - 75% accuracy</li> <li>“Schedule tasks to minimize the overall duration.” (Prompt) - 85% accuracy</li> <li>“Optimize the task assignment for minimal time.” (Prompt) - 87% accuracy</li> </ul> </li> </ul> <p><strong>Step 4:</strong> Now, the updated meta-prompt is used to repeat steps 2 and 3. This process continues until one of the following conditions is met:</p> <ul> <li>The LLM’s generated solutions reach a satisfactory level of accuracy, and further optimization does not significantly improve the results</li> <li>A predefined maximum number of optimization steps is reached.</li> </ul> <h3 id="experiments">Experiments</h3> <p>The authors focus on two optimization problems for their experiments:</p> <ul> <li>Prompt Optimization for Natural Language Tasks: This part focuses on optimizing prompts for natural language tasks. They conduct experiments on datasets such as GSM8K (grade school math word problems) and Big-Bench Hard (BBH), which consists of various challenging tasks. The primary objective is to optimize prompts for these datasets to maximize task accuracy. The OPRO framework was quite successful in optimizing prompts for various natural language tasks. Instructions generated through prompt optimization improved task accuracy significantly compared to initial or baseline prompts. The instructions generated by OPRO demonstrated high transferability and outperformed baseline prompts on different datasets within the same domain.</li> <li>Traveling Salesman Problem (TSP): The researchers also apply their framework, OPRO, to the Traveling Salesman Problem, a classic combinatorial optimization problem. They evaluate the performance of OPRO in comparison to heuristic algorithms and measure the optimality gap. The OPRO framework, when applied to the TSP, demonstrated promising results on smaller-scale TSP problems. However, its performance on larger-scale TSP problems degraded, with heuristics outperforming the language models.</li> </ul> <h3 id="conclusion">Conclusion</h3> <p>This paper presents an innovative approach that leverages Large Language Models (LLMs) to address optimization problems through prompt optimization. The OPRO framework simplifies the presentation of optimization tasks to LLMs, potentially reducing the need for domain-specific expertise and outperforming traditional heuristics in specific cases. The experiments conducted on natural language tasks demonstrate OPRO’s success in improving task accuracy and transferability, while its performance in solving the Traveling Salesman Problem (TSP) varies, excelling in smaller-scale instances but being outperformed by heuristics in larger-scale problems. This approach showcases the promise of LLMs in optimization but is subject to domain-specific constraints and varying levels of effectiveness.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <p class="mb-2">Here are some more articles relevant to this one:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/week-27/">Paper Review - Week 27</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/week-25/">Paper Review - Week 25</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/week-10/">Paper Review - Week 10</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/week-46/">Paper Review - Week 46</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/week-41/">Paper Review - Week 41</a> </li> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Shirin Tahmasebi. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?7254ae07fe9cc5f3a10843e1c0817c9c" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>