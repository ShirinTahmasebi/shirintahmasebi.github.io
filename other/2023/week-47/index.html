<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Paper Review - Week 47 | Shirin Tahmasebi </title> <meta name="author" content="Shirin Tahmasebi"> <meta name="description" content="Top NLP Papers Published from November 20 to November 26 "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?ce48ee9bc248ee6b18f3aeefc03ed2f9"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://shirintahmasebi.github.io/other/2023/week-47/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Shirin Tahmasebi </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">CV </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">Publications</a> <a class="dropdown-item " href="/background/">Background</a> </div> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Notes </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/bias/">Bias</a> <a class="dropdown-item " href="/tokenization/">Tokenization</a> <a class="dropdown-item " href="/llm_judge/">LLM as Evaluator</a> <a class="dropdown-item " href="/prompt/">Prompt Engineering</a> <a class="dropdown-item " href="/compression/">LLM Compression</a> <a class="dropdown-item " href="/agents/">LLM Agents</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/recsys/">Recommendation Systems</a> <a class="dropdown-item " href="/other/">Others</a> </div> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Paper Review - Week 47</h1> <p class="post-meta"> November 26, 2023 </p> <p class="post-tags"> <i class="fa-solid fa-calendar fa-sm"></i> 2023   ·   <i class="fa-solid fa-tag fa-sm"></i> papers   <i class="fa-solid fa-tag fa-sm"></i> weekly-review   <i class="fa-solid fa-tag fa-sm"></i> nlp   <i class="fa-solid fa-tag fa-sm"></i> bias   <i class="fa-solid fa-tag fa-sm"></i> position-bias   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"> <a href="#freshllms-refreshing-large-language-models-with-search-engine-augmentation">FreshLLMs: Refreshing Large Language Models with Search Engine Augmentation</a> <ul> <li class="toc-entry toc-h3"><a href="#introduction">Introduction</a></li> <li class="toc-entry toc-h3"><a href="#research-gap">Research Gap</a></li> <li class="toc-entry toc-h3"> <a href="#solution-freshllm">Solution: FreshLLM</a> <ul> <li class="toc-entry toc-h4"><a href="#freshqa">FRESHQA</a></li> <li class="toc-entry toc-h4"><a href="#freshprompt">FRESHPROMPT</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#experiments">Experiments</a></li> <li class="toc-entry toc-h3"><a href="#conclusion">Conclusion</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#lost-in-the-middle-how-language-models-use-long-contexts">Lost in the Middle: How Language Models Use Long Contexts</a> <ul> <li class="toc-entry toc-h3"><a href="#introduction-1">Introduction</a></li> <li class="toc-entry toc-h3"><a href="#research-gap-1">Research Gap</a></li> <li class="toc-entry toc-h3"> <a href="#solution-and-experiments">Solution (and Experiments)</a> <ul> <li class="toc-entry toc-h4"><a href="#tasks-to-analyze-long-context-usage">Tasks to Analyze Long-Context Usage</a></li> <li class="toc-entry toc-h4"><a href="#experimental-variables">Experimental Variables</a></li> <li class="toc-entry toc-h4"><a href="#models-evaluated">Models Evaluated</a></li> <li class="toc-entry toc-h4"><a href="#metrics-for-evaluation">Metrics for Evaluation</a></li> <li class="toc-entry toc-h4"><a href="#investigation-of-contributing-factors">Investigation of Contributing Factors</a></li> <li class="toc-entry toc-h4"><a href="#findings">Findings</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#conclusion-1">Conclusion</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <p>Here is the list of the most interesting papers published in this week:</p> <ul> <li><a href="/blog/2023/week-47/#freshllms-refreshing-large-language-models-with-search-engine-augmentation">FreshLLMs: Refreshing Large Language Models with Search Engine Augmentation</a></li> <li><a href="/blog/2023/week-47/#lost-in-the-middle-how-language-models-use-long-contexts">Lost in the Middle: How Language Models Use Long Contexts</a></li> </ul> <hr> <h2 id="freshllms-refreshing-large-language-models-with-search-engine-augmentation"><a href="https://arxiv.org/pdf/2305.14283.pdf" rel="external nofollow noopener" target="_blank">FreshLLMs: Refreshing Large Language Models with Search Engine Augmentation</a></h2> <h3 id="introduction">Introduction</h3> <p>This paper introduces FRESHQA, a dynamic question-answering benchmark designed to evaluate the factuality of LLMs in the context of changing world knowledge. The paper explores the limitations of existing LLMs, including their struggle with questions involving fast-changing knowledge and false premises. To address these challenges, the authors introduce FRESHPROMPT, a few-shot prompting method that incorporates relevant and up-to-date information from a search engine into the LLM’s prompt.</p> <h3 id="research-gap">Research Gap</h3> <p>The FreshLLMs paper addresses several research gaps in LLMs and their ability to handle dynamically changing information. Here are some key research gaps that the paper aims to fill:</p> <ul> <li> <strong>Static Nature of LLMs:</strong> Many existing LLMs are trained once and lack mechanisms for dynamic updates. This results in a static representation of knowledge, which can become outdated in a rapidly changing world.</li> <li> <strong>Factuality and Trustworthiness:</strong> LLMs, despite their impressive capabilities, are known to generate responses that may be factually incorrect or outdated. This affects the trustworthiness of their answers, especially in real-world scenarios where accurate and up-to-date information is crucial.</li> <li> <strong>Adaptation to Fast-Changing Knowledge:</strong> The paper identifies a gap in the ability of LLMs to adapt to fast-changing knowledge, such as current events or recent developments. Existing models may struggle to provide accurate answers to questions that require knowledge updates beyond their training data.</li> <li> <strong>Handling False Premises:</strong> LLMs often face challenges in answering questions with false premises. The paper highlights the need to assess how well LLMs can identify and correct false information in the questions they are presented with.</li> </ul> <h3 id="solution-freshllm">Solution: FreshLLM</h3> <p>This paper introduces a novel dataset called FRESHQA along with a prompting approach named FRESHPROMPT.</p> <h4 id="freshqa">FRESHQA</h4> <p>The authors addresses a crucial gap in the field by introducing FRESHQA, a dynamic question-answering dataset designed to evaluate language models’ performance on real-time information tasks. FRESHQA encompasses questions of varying difficulty levels, from <em>one-hop</em> to <em>multi-hop</em>, and considers the dynamicity of information, distinguishing between <em>never-changing</em>, <em>slow-changing</em>, <em>fast-changing</em>, and <em>false-premise</em> scenarios. The dataset is meticulously curated, involving NLP researchers and freelancers to create questions covering diverse topics. Quality control measures, including manual review and removal of duplicates, ensure the dataset’s integrity.</p> <p>The following image represents several example questions in the dataset:</p> <p style="text-align:center;"><img src="/assets/img/weekly-review/freshllm_sample_questions.png" alt="The Architecture" width="700" height="500"></p> <h4 id="freshprompt">FRESHPROMPT</h4> <p>In parallel, they propose FRESHPROMPT, a novel prompting approach tailored to facilitate the answering process for LLMs. FRESHPROMPT leverages information retrieval from search engines, particularly Google Search, to gather relevant data. Given a question, the system queries the search engine, retrieves various result types, and extracts relevant information, such as text snippets, source, date, title, and highlighted words. The extracted evidence is then incorporated into the model’s prompt, enabling in-context learning. Demonstrations and the ordered list of retrieved evidences structure the prompt, guiding the model in understanding the task and producing accurate answers. The ultimate objective is to establish a benchmark for assessing language models in dynamic QA scenarios and to enhance their adaptability to real-time information by leveraging search engine data.</p> <h3 id="experiments">Experiments</h3> <p>The experiments conducted in the study involve benchmarking various language models on the FRESHQA dataset to assess their performance in dynamic question-answering scenarios. The models under evaluation span a range of sizes, from 770M to 540B parameters, and include well-known pre-trained models like T5, PALM, FLAN-T5, GPT-3.5, GPT-4, CODEX, and CHATGPT, among others. Two distinct evaluation modes, RELAXED and STRICT, are employed to measure correctness and hallucination in the models’ responses. The RELAXED evaluation focused on measuring the correctness of the primary answer, allowing for some flexibility in accepting ill-formed responses. In contrast, the STRICT evaluation scrutinized correctness but also whether any hallucination was present in the response.</p> <p>The following image shows several evaluations:</p> <p style="text-align:center;"><img src="/assets/img/weekly-review/freshllm_sample_evaluations.png" alt="The Architecture" width="700" height="250"></p> <p>The main findings highlight the challenges that existing LLMs face in handling questions involving fast-changing knowledge and false premises. Regardless of model size, all models exhibit limitations in these scenarios, emphasizing the need for improvement. The study also reveals that increasing model size does not consistently lead to improved performance on questions with rapidly changing information.</p> <p>Motivated by these challenges, the researchers introduce FRESHPROMPT, an in-context learning method designed to enhance language models’ factuality. FRESHPROMPT leverages search engine outputs to provide up-to-date information, resulting in substantial accuracy improvements. The experiments demonstrate that FRESHPROMPT outperforms other search engine-augmented prompting methods and commercial systems.</p> <h3 id="conclusion">Conclusion</h3> <p>In conclusion, the study delves into the challenges faced by LLMs in handling dynamically changing information and questions with false premises. The introduced FRESHQA dataset serves as a valuable benchmark to assess the factuality of language models, revealing their limitations and the pressing need for improvement. The proposed FRESHPROMPT method showcases promising results, significantly boosting model performance by incorporating real-time information from search engines. This underscores the potential of in-context learning approaches to enhance language models’ adaptability to evolving knowledge.</p> <hr> <h2 id="lost-in-the-middle-how-language-models-use-long-contexts"><a href="https://arxiv.org/pdf/2307.03172.pdf" rel="external nofollow noopener" target="_blank">Lost in the Middle: How Language Models Use Long Contexts</a></h2> <h3 id="introduction-1">Introduction</h3> <p>Language models have become integral to many modern applications, such as conversational AI, search engines, and document summarization. These models typically process input through long contexts, allowing them to perform tasks that involve large amounts of data, such as analyzing legal documents or processing extensive conversation histories. With advances in hardware and algorithms, context windows have expanded from a few thousand tokens to tens or even hundreds of thousands, enabling the potential for richer understanding and better task performance.</p> <p>However, a critical question remains: how effectively do these models use their long contexts? While recent models boast extended input capabilities, there’s limited understanding of their performance in scenarios requiring selective retrieval of information embedded in these extended inputs. This blog post explores findings from a recent paper that investigates the ability of language models to handle long contexts effectively. The paper evaluates several state-of-the-art models using tasks such as multi-document question answering and key-value retrieval. Surprisingly, it reveals that models often perform better when relevant information is located at the beginning or end of the input context but struggle significantly with information in the middle.</p> <h3 id="research-gap-1">Research Gap</h3> <p>Despite advancements in language models’ capacity to process long contexts, their ability to effectively retrieve and use information from these extended inputs remains limited. The study identifies several gaps:</p> <ol> <li> <strong>Position Bias:</strong> Current models exhibit a “U-shaped” performance curve, favoring information positioned at the beginning (primacy bias) or end (recency bias) of the context, while performing poorly on middle-placed information.</li> <li> <strong>Extended Context Effectiveness:</strong> Models with extended context windows do not necessarily outperform their shorter-context counterparts, indicating that merely increasing the input size doesn’t translate into better performance.</li> <li> <strong>Task-Specific Challenges:</strong> For tasks like multi-document question answering, where models must identify and reason over relevant documents, their inability to uniformly handle all positions in the context limits their utility.</li> <li> <strong>Architectural Limitations:</strong> Decoder-only models, commonly used for LLMs, show significant struggles when dealing with longer sequences, especially compared to encoder-decoder architectures.</li> <li> <strong>Practical Implications:</strong> In real-world scenarios, such as retrieval-augmented applications, the inability to robustly use long contexts may result in inefficiencies and errors, highlighting the need for better evaluation and model design.</li> </ol> <p>This paper’s findings highlight the importance of rethinking how language models process and use long contexts, emphasizing the need for architectures and fine-tuning strategies that address these limitations.</p> <h3 id="solution-and-experiments">Solution (and Experiments)</h3> <p>The paper proposes a controlled experimental setup to investigate how well language models handle long contexts. Their approach includes the following key elements:</p> <h4 id="tasks-to-analyze-long-context-usage">Tasks to Analyze Long-Context Usage</h4> <p>The researchers designed two tasks to systematically evaluate the models’ ability to retrieve and use relevant information from long contexts:</p> <ul> <li> <p><strong>Multi-Document Question Answering (QA):</strong> Models are given a query and a set of documents, where one document contains the answer and the rest are distractors. The position of the relevant document is varied systematically (beginning, middle, or end of the context) to test how well the models retrieve and reason over the correct information. This mimics real-world tasks like retrieval-augmented generation, where models process retrieved documents to answer questions.</p> </li> <li> <p><strong>Key-Value Retrieval:</strong><br> A synthetic test designed to minimize linguistic complexity. Models are given a JSON object with randomly generated keys and values and are asked to retrieve the value for a specific key. This task isolates the retrieval mechanism by removing language features as confounders. The position of the key-value pair is similarly varied within the input.</p> </li> </ul> <h4 id="experimental-variables">Experimental Variables</h4> <p>To understand the models’ behavior under different conditions, the researchers manipulated:</p> <ul> <li> <strong>Context Length:</strong> They varied the number of documents or key-value pairs in the input, increasing the input size to test whether longer contexts affect performance.</li> <li> <strong>Position of Relevant Information:</strong> By altering the placement of the relevant document or key-value pair (beginning, middle, or end), they measured how performance changes based on positional bias.</li> </ul> <h4 id="models-evaluated">Models Evaluated</h4> <p>The study tested several state-of-the-art language models, including both open-source and proprietary ones:</p> <ul> <li> <strong>Open Models:</strong> MPT-30B-Instruct, LongChat-13B (16K)</li> <li> <strong>Closed Models:</strong> GPT-3.5-Turbo, GPT-3.5-Turbo (16K), Claude-1.3, Claude-1.3 (100K)</li> </ul> <p>These models represent varying architectural designs and input context sizes, offering a broad view of current capabilities.</p> <h4 id="metrics-for-evaluation">Metrics for Evaluation</h4> <p>The researchers used task-specific metrics, such as:</p> <ul> <li> <strong>Accuracy:</strong> For both tasks, whether the model correctly retrieved the desired answer or value.</li> <li> <strong>Closed-Book vs. Oracle Performance:</strong> To contextualize results, they compared models’ closed-book accuracy (no context provided) and oracle accuracy (provided with only the relevant information).</li> </ul> <h4 id="investigation-of-contributing-factors">Investigation of Contributing Factors</h4> <p>The study also explored why models struggle with middle-context information by analyzing:</p> <ul> <li> <strong>Model Architecture:</strong> Comparing decoder-only and encoder-decoder designs.</li> <li> <strong>Query-Aware Contextualization:</strong> Testing whether placing the query both before and after the context improves performance.</li> <li> <strong>Instruction Fine-Tuning:</strong> Evaluating whether fine-tuning affects positional biases and retrieval robustness.</li> </ul> <h4 id="findings">Findings</h4> <p>The study uncovered several key insights into how language models handle long contexts:</p> <ol> <li>Positional Bias: U-Shaped Performance Curve <ul> <li>Language models perform best when relevant information is located at the beginning (primacy bias) or end (recency bias) of the input context.</li> <li>Performance significantly drops when relevant information appears in the middle of the input, forming a “U-shaped” curve. For example, GPT-3.5-Turbo’s accuracy in the middle-context setting can fall below its closed-book performance.</li> </ul> </li> <li>Limited Advantage of Extended Context Models <ul> <li>Models with larger context windows (e.g., GPT-3.5-Turbo 16K and Claude 100K) do not necessarily perform better than their standard counterparts when the input fits within both models’ context sizes.</li> <li>Simply increasing the input size capability does not translate into better usage of long contexts.</li> </ul> </li> <li>Task-Specific Challenges <ul> <li>In <strong>multi-document question answering</strong>, models struggle to retrieve and reason over relevant documents when the answer is embedded in the middle of the context. This occurs even when only one document contains the correct answer.</li> <li>In <strong>key-value retrieval</strong>, some models, like Claude, perform perfectly, but others exhibit the same U-shaped performance trend as in the QA task.</li> </ul> </li> <li>Architectural Observations <ul> <li> <strong>Decoder-only models</strong> (e.g., GPT-3.5, MPT-30B) exhibit stronger positional biases than <strong>encoder-decoder models</strong> (e.g., Flan-T5-XXL, Flan-UL2). Encoder-decoder models process context more robustly but still struggle when input lengths exceed their training-time limits.</li> <li>Instruction fine-tuning slightly mitigates biases but does not eliminate them, especially for larger models.</li> </ul> </li> <li>Practical Implications <ul> <li>For retrieval-augmented tasks (e.g., open-domain QA), increasing the number of retrieved documents provides diminishing returns. Models struggle to use additional documents effectively, even when they contain relevant information.</li> <li>Effective document ranking and truncation strategies could improve performance by placing relevant information near the beginning or end of the input.</li> </ul> </li> <li>Query-Aware Contextualization <ul> <li>Placing the query both before and after the input context significantly improves performance in simple tasks like key-value retrieval.</li> <li>However, this strategy has limited impact on more complex tasks like multi-document question answering.</li> </ul> </li> <li>Scaling and Model Size <ul> <li>The U-shaped positional bias becomes more pronounced in larger models (e.g., 13B and 70B parameters). Smaller models tend to exhibit primarily recency bias.</li> <li>Scaling models and fine-tuning with human feedback reduce, but do not completely resolve, positional biases.</li> </ul> </li> </ol> <h3 id="conclusion-1">Conclusion</h3> <p>These findings reveal that current language models do not robustly utilize long input contexts. Positional biases and inefficiencies in reasoning over middle-context information present significant limitations, even in extended-context models. These insights underscore the need for architectural improvements and better training strategies to fully leverage long-context capabilities.</p> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Shirin Tahmasebi. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?7254ae07fe9cc5f3a10843e1c0817c9c" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>