<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Found in the Middle | Shirin Tahmasebi </title> <meta name="author" content="Shirin Tahmasebi"> <meta name="description" content="Permutation Self-Consistency Improves Listwise Ranking in Large Language Models "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?ce48ee9bc248ee6b18f3aeefc03ed2f9"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://shirintahmasebi.github.io/bias/2024/found_in_the_middle/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Shirin Tahmasebi </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">CV </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">Publications</a> <a class="dropdown-item " href="/background/">Background</a> </div> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Notes </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/bias/">Bias</a> <a class="dropdown-item " href="/tokenization/">Tokenization</a> <a class="dropdown-item " href="/llm_judge/">LLM as Evaluator</a> <a class="dropdown-item " href="/prompt/">Prompt Engineering</a> <a class="dropdown-item " href="/compression/">LLM Compression</a> <a class="dropdown-item " href="/agents/">LLM Agents</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/recsys/">Recommendation Systems</a> <a class="dropdown-item " href="/other/">Others</a> </div> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Found in the Middle</h1> <p class="post-meta"> April 28, 2024 </p> <p class="post-tags"> <i class="fa-solid fa-calendar fa-sm"></i> 2024   ·   <i class="fa-solid fa-hashtag fa-sm"></i> bias   <i class="fa-solid fa-hashtag fa-sm"></i> position-bias   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"> <a href="#found-in-the-middle-permutation-self-consistency-improves-listwise-ranking-in-large-language-models">Found in the Middle: Permutation Self-Consistency Improves Listwise Ranking in Large Language Models</a> <ul> <li class="toc-entry toc-h3"><a href="#introduction">Introduction</a></li> <li class="toc-entry toc-h3"><a href="#research-gap">Research Gap</a></li> <li class="toc-entry toc-h3"> <a href="#background">Background</a> <ul> <li class="toc-entry toc-h4"><a href="#kendall-tau-distance">Kendall Tau Distance</a></li> <li class="toc-entry toc-h4"><a href="#central-ranking">Central Ranking</a></li> <li class="toc-entry toc-h4"><a href="#kemenyyoung-method">Kemeny–Young Method</a></li> </ul> </li> <li class="toc-entry toc-h3"> <a href="#solution-permutation-self-consistency-psc">Solution: Permutation Self-Consistency (PSC)</a> <ul> <li class="toc-entry toc-h4"><a href="#step-1-shuffle-the-input-list">Step 1: Shuffle the Input List</a></li> <li class="toc-entry toc-h4"><a href="#step-2-generate-rankings-for-each-shuffle">Step 2: Generate Rankings for Each Shuffle</a></li> <li class="toc-entry toc-h4"><a href="#step-3-aggregate-rankings">Step 3: Aggregate Rankings</a></li> <li class="toc-entry toc-h4"><a href="#step-4-output-the-final-ranking">Step 4: Output the Final Ranking</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#why-it-works">Why It Works</a></li> <li class="toc-entry toc-h3"><a href="#efficiency-considerations">Efficiency Considerations</a></li> <li class="toc-entry toc-h3"> <a href="#experiments">Experiments</a> <ul> <li class="toc-entry toc-h4"> <a href="#1-sorting-tasks">1. Sorting Tasks</a> <ul> <li class="toc-entry toc-h5"><a href="#setup">Setup</a></li> <li class="toc-entry toc-h5"><a href="#results">Results</a></li> </ul> </li> <li class="toc-entry toc-h4"> <a href="#2-passage-reranking-tasks">2. Passage Reranking Tasks</a> <ul> <li class="toc-entry toc-h5"><a href="#setup-1">Setup</a></li> <li class="toc-entry toc-h5"><a href="#results-1">Results</a></li> </ul> </li> <li class="toc-entry toc-h4"><a href="#3-positional-bias-analysis">3. Positional Bias Analysis</a></li> <li class="toc-entry toc-h4"><a href="#key-findings">Key Findings</a></li> </ul> </li> <li class="toc-entry toc-h3"><a href="#conclusion">Conclusion</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <h2 id="found-in-the-middle-permutation-self-consistency-improves-listwise-ranking-in-large-language-models"><a href="https://arxiv.org/pdf/2310.07712" rel="external nofollow noopener" target="_blank">Found in the Middle: Permutation Self-Consistency Improves Listwise Ranking in Large Language Models</a></h2> <h3 id="introduction">Introduction</h3> <p>Large Language Models (LLMs) have revolutionized the field of natural language processing by demonstrating state-of-the-art performance across a variety of tasks. Among these tasks, listwise ranking—where items in a list are arranged based on relevance or importance—has gained particular attention in applications like search engines, recommendation systems, and document retrieval. However, LLMs often exhibit positional biases, where the order of items in the input list can affect the quality of the output ranking. This sensitivity can lead to inconsistent results and undermine the reliability of LLM-based ranking systems. To address this challenge, researchers have been exploring methods to improve ranking consistency and robustness against positional biases.</p> <h3 id="research-gap">Research Gap</h3> <p>While existing methods attempt to mitigate positional biases in LLMs, most rely on either modifying the input prompt or introducing additional training, which may not be feasible for proprietary or black-box models. Furthermore, current approaches often fail to adequately address order dependence in listwise ranking tasks, where the performance of the model varies significantly with the input order. This limitation becomes more pronounced in real-world applications where input lists are inherently unordered, and the model’s output should be invariant to the order of input items. To bridge this gap, the proposed study introduces <strong>Permutation Self-Consistency (PSC)</strong>, a novel method that aggregates rankings generated from multiple shuffled inputs to produce a final order-independent ranking, effectively reducing positional biases without requiring model fine-tuning.</p> <h3 id="background">Background</h3> <h4 id="kendall-tau-distance">Kendall Tau Distance</h4> <p>The <strong>Kendall tau distance</strong> is a metric used to measure how <em>different</em> two rankings are by counting the number of pairwise disagreements between them. It is widely used in ranking tasks to evaluate how one ordering deviates from another. But, how it work?</p> <p>Given two rankings, \(\sigma_1\) and \(\sigma_2\), the Kendall tau distance is calculated as:</p> \[d_\kappa(\sigma_1, \sigma_2) = \text{Number of discordant pairs in } \sigma_1 \text{ and } \sigma_2\] <ul> <li> <strong>Discordant Pair</strong>: A pair of items \((i, j)\) is considered discordant if the relative ordering of \(i\) and \(j\) is different in \(\sigma_1\) and \(\sigma_2\). For example: <ul> <li>In \(\sigma_1\), if \(i &gt; j\) (item \(i\) is ranked higher than \(j\)).</li> <li>In \(\sigma_2\), if \(j &gt; i\) (item \(j\) is ranked higher than \(i\)).</li> </ul> </li> </ul> <p>Let us have some examples: Consider two rankings of items \(A, B, C, D\):</p> <ul> <li>Ranking 1: \(\sigma_1 = [A, B, C, D]\)</li> <li>Ranking 2: \(\sigma_2 = [B, A, D, C]\)</li> </ul> <ol> <li>Compare pairs of items: <ul> <li>\((A, B)\): \(A &gt; B\) in \(\sigma_1\), \(B &gt; A\) in \(\sigma_2\) → <strong>Discordant</strong>.</li> <li>\((A, C)\): \(A &gt; C\) in both → <strong>Concordant</strong>.</li> <li>\((A, D)\): \(A &gt; D\) in both → <strong>Concordant</strong>.</li> <li>\((B, C)\): \(B &gt; C\) in \(\sigma_1\), \(C &gt; B\) in \(\sigma_2\) → <strong>Discordant</strong>.</li> <li>\((B, D)\): \(B &gt; D\) in \(\sigma_1\), \(D &gt; B\) in \(\sigma_2\) → <strong>Discordant</strong>.</li> <li>\((C, D)\): \(C &gt; D\) in \(\sigma_1\), \(D &gt; C\) in \(\sigma_2\) → <strong>Discordant</strong>.</li> </ul> </li> <li>Total Discordant Pairs: 4</li> </ol> \[d_\kappa(\sigma_1, \sigma_2) = 4\] <p>But, why and how it can be useful?</p> <ul> <li> <strong>Quantifies Differences</strong>: The Kendall tau distance provides a precise way to measure the disagreement between rankings.</li> <li> <strong>Symmetry</strong>: \(d_\kappa(\sigma_1, \sigma_2) = d_\kappa(\sigma_2, \sigma_1)\), making it easy to compute regardless of the reference order.</li> </ul> <h4 id="central-ranking">Central Ranking</h4> <p>A <strong>central ranking</strong> is a single ranking that best represents the consensus of multiple rankings. It is found by minimizing the total Kendall tau distance between the central ranking and all the input rankings.</p> <p>If we have \(m\) rankings \(\sigma_1, \sigma_2, \dots, \sigma_m\), the central ranking \(\sigma_\text{central}\) is defined as:</p> \[\sigma_\text{central} = \arg \min_{\sigma} \sum_{i=1}^m d_\kappa(\sigma, \sigma_i)\] <p>This means \(\sigma_\text{central}\) is the ranking that has the smallest total pairwise distance (Kendall tau distance) to all the individual rankings.</p> <p>But, why and how it can be useful?</p> <ul> <li> <strong>Consensus Representation</strong>: It summarizes multiple rankings into one, ensuring it reflects the “most agreed upon” ordering.</li> <li> <strong>Order Independence</strong>: By minimizing distances to all rankings, it is robust to biases or variations in individual rankings.</li> </ul> <p>Let us have some examples. Suppose we have three rankings:</p> <ol> <li>Ranking 1: \(\sigma_1 = [A, B, C]\)</li> <li>Ranking 2: \(\sigma_2 = [B, C, A]\)</li> <li>Ranking 3: \(\sigma_3 = [C, A, B]\)</li> </ol> <p>To find the central ranking:</p> <ol> <li>Compute Kendall tau distances between all possible rankings and the input rankings.</li> <li>The ranking that minimizes the total distance is the <strong>central ranking</strong>.</li> </ol> <p>For this case, the central ranking might be \(B &gt; C &gt; A\), as it minimizes the pairwise disagreements with \(\sigma_1, \sigma_2, \sigma_3\).</p> <h4 id="kemenyyoung-method">Kemeny–Young Method</h4> <p>The <strong>Kemeny–Young method</strong> is a mathematical approach for finding the central ranking. It works by evaluating all possible rankings and selecting the one that minimizes the total Kendall tau distance to the input rankings. While this method is <strong>NP-hard</strong> (computationally expensive), efficient approximations can be used for practical cases. This method ensures that the final ranking reflects a robust consensus of all input rankings, reducing the impact of noise or biases in any single ranking.</p> <h3 id="solution-permutation-self-consistency-psc">Solution: Permutation Self-Consistency (PSC)</h3> <p>To tackle positional biases in listwise ranking tasks, the authors propose <strong>Permutation Self-Consistency (PSC)</strong>, a novel decoding strategy designed to improve ranking quality, consistency, and robustness to input order. The method leverages multiple shuffled versions of the input list, processes them independently through the language model, and then combines the outputs to produce a robust, order-independent ranking.</p> <p style="text-align:center;"><img src="/assets/img/weekly-review/psc_architecture.png" alt="An Overviw of PSC" width="750" height="300"></p> <p>Here’s a step-by-step breakdown of their solution:</p> <h4 id="step-1-shuffle-the-input-list">Step 1: Shuffle the Input List</h4> <p>The first step involves <strong>shuffling the input list multiple times</strong>. For instance, if the task is to rank passages based on relevance to a query, the list of passages is shuffled randomly \(m\) times (e.g., \(m = 20\)). Each shuffled version of the list is then passed through the LLM along with the same instructions.</p> <ul> <li>Why shuffle? Shuffling the input list introduces diverse orderings, ensuring that positional biases associated with any one specific order are averaged out during the aggregation phase.</li> <li>Example:<br> Original input: \([A, B, C]\)<br> Shuffles: \([B, A, C], [C, B, A], [A, C, B], \dots\)</li> </ul> <h4 id="step-2-generate-rankings-for-each-shuffle">Step 2: Generate Rankings for Each Shuffle</h4> <p>Each shuffled list is processed independently by the LLM to produce a ranked output. The LLM provides a ranking of items for each input order.</p> <ul> <li>Key Insight: The rankings generated for different shuffles may vary due to positional biases inherent in the model. Some shuffles may place undue importance on items appearing earlier or later in the list.</li> <li>Output Example:<br> For \([B, A, C]\), the LLM might rank items as \(A &gt; C &gt; B\).<br> For \([C, B, A]\), the LLM might output \(B &gt; A &gt; C\).</li> </ul> <h4 id="step-3-aggregate-rankings">Step 3: Aggregate Rankings</h4> <p>To combine the rankings generated from all \(m\) shuffles, the method uses a robust <strong>aggregation strategy</strong>. Specifically, the authors employ the <strong>Kemeny–Young method</strong>, which finds the ranking that minimizes the total pairwise disagreements (measured using Kendall tau distance) with all the generated rankings.</p> <ul> <li>Kemeny–Young Aggregation:* <ul> <li>Given \(m\) rankings, it identifies the <strong>central ranking</strong> that best represents the consensus.</li> <li>This ranking is the one that is closest to all \(m\) rankings in terms of Kendall tau distance, which measures how “out of order” one ranking is compared to another.</li> </ul> </li> <li>Example: If the rankings from 3 shuffles are:<br> \(A &gt; C &gt; B\), \(B &gt; A &gt; C\), and \(C &gt; A &gt; B\),<br> the Kemeny–Young method would calculate the disagreements between all pairs of rankings and output the ranking \(A &gt; B &gt; C\) as the central consensus.</li> </ul> <h4 id="step-4-output-the-final-ranking">Step 4: Output the Final Ranking</h4> <p>The final step is to return the <strong>central ranking</strong> as the output. This ranking is:</p> <ol> <li> <strong>Order-independent</strong>: It does not depend on the specific order of the input list.</li> <li> <strong>Robust</strong>: Positional biases introduced by any single shuffle are averaged out through aggregation.</li> <li> <strong>Improved in quality</strong>: By leveraging multiple perspectives (shuffles), the final ranking better captures the relationships among items.</li> </ol> <h3 id="why-it-works">Why It Works</h3> <ol> <li> <strong>Randomization Breaks Biases</strong>: Randomly shuffling the input list ensures that no single input order dominates the LLM’s behavior.</li> <li> <strong>Consensus Reduces Noise</strong>: Aggregating multiple rankings effectively marginalizes out positional biases, producing a more reliable final ranking.</li> <li> <strong>Order Independence</strong>: By considering all possible input orders (via shuffles), the method creates a ranking invariant to how the items were presented.</li> </ol> <h3 id="efficiency-considerations">Efficiency Considerations</h3> <ul> <li> <strong>Shuffles (\(m\))</strong>: The authors find that even a small number of shuffles (\(m = 5\) to \(10\)) significantly improves ranking quality, with diminishing returns for larger \(m\).</li> <li> <strong>Aggregation Cost</strong>: While exact Kemeny–Young aggregation is computationally expensive (\(O(n!)\)), the authors use efficient approximations (\(O(m^2 \cdot n^2)\)) to handle practical scenarios like 20 items and 20 shuffles.</li> </ul> <p>This method is particularly effective for tasks like passage reranking, sentence ordering, and word sorting, where input lists are inherently unordered and positional biases can significantly impact results.</p> <h3 id="experiments">Experiments</h3> <p>The authors evaluate the effectiveness of PSC through experiments on <strong>sorting tasks</strong> and <strong>passage reranking tasks</strong>. These tasks demonstrate how PSC improves ranking performance and reduces positional biases.</p> <h4 id="1-sorting-tasks">1. Sorting Tasks</h4> <p>The authors use three synthetic datasets to evaluate PSC on tasks with inherently comparable items:</p> <ul> <li> <strong>MathSort</strong>: Sort arithmetic expressions by value.</li> <li> <strong>WordSort</strong>: Arrange words alphabetically.</li> <li> <strong>GSM8KSort</strong>: Order scrambled sentences from a reasoning dataset.</li> </ul> <h5 id="setup">Setup</h5> <ul> <li>Five LLMs are tested: GPT-3.5, GPT-4, and open-source models like LLaMA2 and Mistral.</li> <li>\(m = 20\) shuffled input lists are used for each example, and the results are aggregated with PSC.</li> </ul> <h5 id="results">Results</h5> <ul> <li>PSC improves performance across all tasks and models, with significant gains for smaller models (e.g., LLaMA2-7B improved by 157% on MathSort).</li> <li>Even for powerful models like GPT-4, PSC yields moderate improvements (e.g., 2–7%).</li> <li>PSC consistently outperforms individual runs and standard inference methods by combining rankings from multiple permutations.</li> </ul> <h4 id="2-passage-reranking-tasks">2. Passage Reranking Tasks</h4> <p>The authors assess PSC on real-world datasets:</p> <ul> <li> <strong>TREC Deep Learning Tracks (DL19 &amp; DL20)</strong>: Passage ranking datasets where passages are ranked by relevance to a query.</li> </ul> <h5 id="setup-1">Setup</h5> <ul> <li>Inputs include \(n = 20\) or \(n = 100\) passages.</li> <li>Models tested: GPT-3.5, GPT-4, and RankVicuna (an open-source fine-tuned model).</li> <li>PSC is compared against baseline methods like RankGPT and RankVicuna.</li> </ul> <h5 id="results-1">Results</h5> <ul> <li>PSC consistently improves nDCG@10 scores (a ranking quality metric).</li> <li>For GPT-4, PSC boosts ranking performance by up to 5% relative to baseline methods.</li> <li>Smaller models (e.g., GPT-3.5) see smaller but meaningful improvements.</li> <li>The method achieves significant gains even with fewer shuffles (\(m = 5–10\)).</li> </ul> <h4 id="3-positional-bias-analysis">3. Positional Bias Analysis</h4> <p>The authors analyze how PSC mitigates positional biases by studying the impact of input order:</p> <ul> <li>Models like GPT-3.5 and GPT-4 exhibit positional biases (e.g., favoring items at the start or end of the list).</li> <li>PSC reduces these biases by averaging over multiple shuffled inputs, leading to fairer rankings.</li> </ul> <h4 id="key-findings">Key Findings</h4> <ul> <li>PSC works well across both synthetic and real-world ranking tasks.</li> <li>It provides larger gains for smaller models and more challenging tasks, where positional biases are more prominent.</li> <li>The method scales effectively with \(n = 20\) items and \(m = 20\) shuffles, balancing quality improvements with computational cost.</li> </ul> <p>These experiments demonstrate that PSC is a robust and practical method for improving ranking quality and mitigating positional biases in LLMs.</p> <h3 id="conclusion">Conclusion</h3> <p>Permutation Self-Consistency (PSC) is a simple yet effective method for mitigating positional biases in listwise ranking tasks. By aggregating rankings from multiple shuffled inputs, PSC produces robust, order-independent results without requiring model fine-tuning. Experiments on both synthetic sorting tasks and real-world passage reranking datasets demonstrate significant improvements in ranking quality, particularly for smaller models and challenging scenarios. With its scalability and ability to work with black-box LLMs, PSC offers a practical solution for improving the fairness and consistency of ranking systems powered by large language models.</p> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Shirin Tahmasebi. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?7254ae07fe9cc5f3a10843e1c0817c9c" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>